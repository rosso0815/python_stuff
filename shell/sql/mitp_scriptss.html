<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><HTML>
<HEAD>
<TITLE></TITLE>
</HEAD>
<BODY>
<A name=1></a>connect SYS/change_on_install as SYSDBA <br>set echo on <br>spool /var/oracle/OraHome2/assistants/dbca/logs/CreateDB.log <br>startup nomount pfile=&quot;/var/oracle/OraHome2/admin/galinux2/scripts/<br>init.ora&quot;; <br>CREATE DATABASE galinux2 <br>MAXINSTANCES 1 <br>MAXLOGHISTORY 1 <br>MAXLOGFILES 5 <br>MAXLOGMEMBERS 5 <br>MAXDATAFILES 100 <br>DATAFILE '/var/oracle/OraHome2/oradata/galinux2/system01.dbf' SIZE 325M <br>REUSE<br>AUTOEXTEND ON NEXT  10240K MAXSIZE UNLIMITED <br>UNDO TABLESPACE &quot;UNDOTBS&quot; DATAFILE <br>'/var/oracle/OraHome2/oradata/galinux2/undotbs01.dbf' SIZE 200M REUSE <br>AUTOEXTEND ON NEXT  5120K MAXSIZE UNLIMITED <br>CHARACTER SET US7ASCII <br>NATIONAL CHARACTER SET AL16UTF16 <br>LOGFILE GROUP 1 ('/var/oracle/OraHome2/oradata/galinux2/redo01.log') SIZE<br>100M, <br>GROUP 2 ('/var/oracle/OraHome2/oradata/galinux2/redo02.log') SIZE 100M,    <br>GROUP 3 ('/var/oracle/OraHome2/oradata/galinux2/redo03.log') SIZE 100M;   <br>spool off <br>exit;<br>
<i>Quellcode 2.1: Beispielskript zum Erstellen einer Datenbank mit Database Creation Assistant (DBCA)</i><br>
REM <br>REM NAME        : init_ora_rct.sql <br>REM FUNCTION    : Recreate the instance init.ora file <br>REM USE         : GENERAL <br>REM Limitations : None <br>REM <br>SET NEWPAGE 0 VERIFY OFF <br>SET ECHO OFF feedback off termout off PAGES 300 lines 80 heading off <br>column name  format a80 word_wrapped <br>column dbname new_value db noprint <br>select name dbname from v$database; <br>DEFINE OUTPUT = 'rep_out\&amp;db\init.ora' <br>SPOOL &amp;OUTPUT <br>SELECT '# Init.ora file from v$parameter' name from dual <br>union <br>select '# generated on:'||sysdate name from dual <br>union <br>select '# script by MRA 08/7/01 TUSC' name from dual <br>union <br>select '#' name from dual <br>UNION <br>SELECT name||' = '||value name  FROM V$PARAMETER <br>WHERE value is not null and ISDEFAULT='FALSE'; <br>SPOOL OFF <br>CLEAR COLUMNS <br>SET NEWPAGE 0 VERIFY OFF <br>SET ECHO ON termout on PAGES 22 lines 80 heading on <br>SET TERMOUT ON <br>UNDEF OUTPUT <br>PAUSE Press enter to continue<br>
<i>Quellcode 2.2: Skript zum Neuerstellen der Initialisierungsdatei.</i><br>
<hr>
<A name=2></a>REM<br>REM ORA_KILL.SQL<br>REM FUNCTION: Kills nonessential Oracle sessions (those that aren't<br>REM owned)<br>REM          : by SYS or &quot;NULL&quot;<br>REM DEPENDENCIES: Depends on kill_session procedure<br>REM MRA 9/12/96<br>REM<br>SET HEADING OFF TERMOUT OFF VERIFY OFF ECHO OFF<br>SPOOL kill_all.sql<br>SELECT 'EXECUTE kill_session('||chr(39)||sid||chr(39)||','||<br>chr(39)||serial#||chr(39)||');' FROM v$session<br>WHERE username IS NOT NULL<br>OR username &lt;&gt; 'SYS'<br>/<br>SPOOL OFF<br>START kill_all.sql<br>
The kill_session procedure Is defined as:<br>
CREATE OR REPLACE PROCEDURE kill_session ( session_id in varchar2,<br>serial_num in varchar2)<br>AS<br>cur INTEGER;<br>ret INTEGER;<br>string VARCHAR2(100);<br>BEGIN<br>--<br>-- Comment out the following three lines to<br>-- not use KILL<br>--<br>string :=<br>'ALTER SYSTEM KILL SESSION' || CHR(10) ||<br>CHR(39)||session_id||','||serial_num||CHR(39);<br>--<br>-- Uncomment the following 4 lines to use DISCONNECT<br>--<br>-- string :=<br>--          'ALTER SYSTEM DISCONNECT SESSION' || CHR(10) ||<br>-- CHR(39)||session_id||','||serial_num||CHR(39)||CHR(10)||<br>--' POST_TRANSACTION';<br>cur := dbms_sql.open_cursor;<br>dbms_sql.parse(cur,string,dbms_sql.v7);<br>ret := dbms_sql.execute(cur)  ;<br>dbms_sql.close_cursor(cur);<br>EXCEPTION<br>WHEN OTHERS THEN<br>raise_application_error(-20001,'Error in execution',TRUE);<br>IF dbms_sql.is_open(cur) THEN<br>dbms_sql.close_cursor(cur); END IF;<br>END; /<br>
<i>Quellcode 2.3: Die ORA_KILL.SQL-Prozedur zum Abbrechen unwesentlicher Oracle-Sitzungen</i><br>
<hr>
<A name=3></a>#!/bin/ksh<br>ORATAB=/etc/oratab<br>trap 'exit' 1 2 3<br># Set path if path not set (if called from /etc/rc)<br>case $PATH in<br>         &quot;&quot;)     PATH=/bin:/usr/bin:/etc<br>           export PATH ;;<br>esac<br>rm kill.lis<br>rm proc.lis<br>touch kill.lis<br>touch proc.lis<br>#<br># Loop for every entry in oratab<br>#<br>cat $ORATAB | while read LINE<br>do<br>        case $LINE in<br>        \#*)          ;;     #comment-line in oratab<br>       *)<br>       ORACLE_SID='echo $LINE | awk -F: '{print $1}' -'<br>     if [ &quot;$ORACLE_SID&quot; = '*' ] ; then<br>           ORACLE_SID=&quot;&quot;<br>     fi<br>        esac<br>        if [ &quot;$ORACLE_SID&quot; &lt;&gt; '*' ] ; then<br>              proc_name='oracle'$ORACLE_SID<br>            ps -ef|grep $proc_name&gt;&gt;proc.lis<br>        fi<br>done<br>cat proc.lis | while read LINE2<br>do<br>           command='echo $LINE2 | awk -F: 'BEGIN { FS = &quot;,[ \t]*|[ \t]+&quot; }<br>                              { print $2}' -'<br>               test_it='echo $LINE2|awk -F: 'BEGIN { FS = &quot;,[ \t]*|[ \t]+&quot; }<br>                              { print $8}' -'<br>             if [ &quot;$test_it&quot; &lt;&gt; 'grep' ] ; then<br>                   command='kill -9 '$command<br>             echo $command&gt;&gt;kill.lis<br>       fi<br>done<br>rm proc.lis<br>chmod 755 kill.lis<br>kill.lis<br>rm kill.lis<br>
<i>Quellcode 2.4: Shell-Skript zum Abbrechen unwesentlicher Oracle-Prozesse von der Server-Seite</i><br>
<hr>
<A name=4></a>REM Script for getting undocumented init.ora<br>REM parameters from a 7.3, 8.0.x,8.1 or 9.0 instance<br>REM MRA - TUSC 4/23/97<br>REM<br>COLUMN parameter           FORMAT a37<br>COLUMN description         FORMAT a30 WORD_WRAPPED<br>COLUMN &quot;Session Value&quot;     FORMAT a10<br>COLUMN &quot;Instance Value&quot;    FORMAT a10<br>SET LINES 100<br>SET PAGES 0<br>SPOOL undoc.lis<br>SELECT<br>     a.ksppinm  &quot;Parameter&quot;,<br>     a.ksppdesc &quot;Description&quot;,<br>     b.ksppstvl &quot;Session Value&quot;,<br>     c.ksppstvl &quot;Instance Value&quot;<br>FROM<br>     x$ksppi a,<br>     x$ksppcv b,<br>     x$ksppsv c<br>WHERE<br>     a.indx = b.indx<br>     AND a.indx = c.indx<br>     AND a.ksppinm LIKE '/_%' escape '/'<br>/<br>SPOOL OFF<br>SET LINES 80 PAGES 20<br>CLEAR COLUMNS<br>
<i>Quellcode 2.5: Skript zum Abrufen der undokumentierten Initailisierungsparameter</i><br>
<hr>
<A name=5></a>How to dump a segment header - by Don Burleson <br>set heading off;<br>spool dump_em.sql;<br>select<br>'alter session set events ''immediate trace name blockdump level '||<br>to_char((header_file*16777216)+header_block)||''';'<br>from<br>dba_segments<br>where<br>segment_name = 'VBAP';<br>
spool off;<br>
cat dump_em.sql <br>@dump_em<br>
<i>Quellcode 2.7: Der Einsatz von SET EVENTS auf Sitzungsebene</i><br>
<hr>
<A name=6></a>rem *************************************************************<br>rem NAME    : BOUND_OB.sql<br>rem FUNCTION: Show objects with extents bounded by freespace<br>rem *************************************************************<br>START title80 &quot;Objects With Extents Bounded by Free Space&quot;<br>SPOOL rep_out\&amp;db\b_ob..lis<br>COLUMN e FORMAT a15        HEADING &quot;TABLE SPACE&quot;<br>COLUMN a FORMAT a6         HEADING &quot;OBJECT|TYPE&quot;<br>COLUMN b FORMAT a30        HEADING &quot;OBJECT NAME&quot;<br>COLUMN c FORMAT a10        HEADING &quot;OWNER ID&quot;<br>COLUMN d FORMAT 99,999,999 HEADING &quot;SIZE|IN BYTES&quot;<br>BREAK ON e SKIP 1 ON c<br>SET FEEDBACK OFF<br>SET VERIFY OFF<br>SET TERMOUT OFF<br>COLUMN bls NEW_VALUE block_size NOPRINT<br>SELECT blocksize bls<br>FROM sys.ts$<br>WHERE name='SYSTEM';<br>
SELECT h.name e, g.name c, f.object_type a, e.name b,<br>       b.length*&amp;&amp;block_size d<br> FROM sys.uet$ b, sys.fet$ c, sys.fet$ d, sys.obj$ e,<br>      sys.sys_objects f,sys.user$ g, sys.ts$ h<br> WHERE b.block# = c.block# + c.length<br>   AND b.block# + b.length = d.block#<br>   AND f.header_file = b.segfile#<br>   AND f.header_block = b.segblock#<br>   AND f.object_id = e.obj#<br>   AND g.user# = e.owner#<br>   AND b.ts# = h.ts#<br> ORDER BY 1,2,3,4<br>/<br>
CLEAR COLUMNS<br>SET FEEDBACK ON<br>SET VERIFY ON<br>SET TERMOUT ON<br>TTITLE ''<br>TTITLE OFF<br>SPOOL OFF<br>CLEAR BREAKS<br>
<i>Quellcode 3.1: Skripten zur Ermittlung der eingeschlossenen Objekte</i><br>
<hr>
<A name=7></a>-- Zunächst wird der Paketrumpf erstellt<br>-- Paket wird verwendet, damit alle Prozeduren<br>-- am selben Speicherort vorhanden und gut zu<br>-- steuern sind <br>-- M. Ault 1/14/97 Rev 1.0<br>--<br>CREATE OR REPLACE PACKAGE cascade_update AS<br>--<br>-- Erstes Paket ist update_column<br>-- Dieses Paket führt die Arbeit mithilfe von<br>-- DBMS_SQL aus, um die UPDATEs zur Laufzeit für<br>-- jede Tabelle neu zu erstellen.<br>--<br>PROCEDURE update_column(<br>     old_value      IN VARCHAR2,<br>     new_value      IN VARCHAR2,<br>     table_name     IN VARCHAR2,<br>     update_column  IN VARCHAR2<br>);<br>--<br>-- Nächste Prozedur ist update_tables<br>-- Dies ist die Prozedur zur Schleifensteuerung<br>-- für den Trigger und ruft update_column auf<br>--<br>PROCEDURE update_tables(<br>     source_table   IN VARCHAR2,<br>     old_value      IN VARCHAR2,<br>     new_value      IN VARCHAR2<br>);<br>--<br>-- ENDE DES PAKET-HEADERS<br>--<br>END cascade_update;<br>/<br>--<br>-- Jetzt wird der Paketrumpf erstellt,<br>-- der die eigentlichen Prozeduren und<br>-- den Code enthält<br>--<br>CREATE OR REPLACE PACKAGE BODY cascade_update AS<br>PROCEDURE update_column(<br>     old_value      IN VARCHAR2,<br>     new_value      IN VARCHAR2,<br>     table_name     IN VARCHAR2,<br>     update_column  IN VARCHAR2)<br>AS<br>--<br>-- Statusvariablen für die dbms_sql-Prozeduren definieren<br>--<br>     cur INTEGER;<br>     rows_processed INTEGER;<br>--<br>-- Verarbeitung starten<br>-- (dbms_output-Aufrufe für das Debugging für<br>-- den normalen Betrieb auskommentieren!)<br>--<br>BEGIN<br>DBMS_OUTPUT.PUT_LINE(<br>'Table name: '||table_name||' Column: '||update_column);<br>     --<br>     -- Initialisierung der dynamischen Cursorposition<br>     -- für die Verarbeitung in dbms_sql<br>     --<br>     cur:=DBMS_SQL.OPEN_CURSOR;<br>     --<br>
<hr>
<A name=8></a>     -- initialisierten Speicherort mit der zu<br>     -- verarbeitenden Anweisung füllen<br>     --<br>DBMS_OUTPUT.PUT_LINE(<br>'UPDATE '||table_name||<br>' SET '||update_column||'='||chr(39)||new_value||chr(39)||<br>chr(10)||' WHERE '||<br>update_column||'='||chr(39)||old_value||chr(39)||<br>' AND 1=1');<br>     --<br>     dbms_sql.parse(cur,<br>     'UPDATE '||table_name||<br>' set '||update_column||'='||chr(39)||new_value||chr(39)||<br>chr(10)||' WHERE '||<br>update_column||'='||chr(39)||old_value||chr(39)||<br>' AND 1=1',dbms_sql.native);<br>     --<br>     -- dynamisch analysierte Anweisung ausführen<br>     --<br>     rows_processed:=DBMS_SQL.EXECUTE(cur);<br>     --<br>     -- dynamischen Cursor zur Vorbereitung auf<br>     -- die nächste Tabelle schließen<br>     --<br>     DBMS_SQL.CLOSE_CURSOR(cur);<br>--<br>-- ENDE DER PROZEDUR<br>--<br>END update_column;<br>--<br>PROCEDURE update_tables(<br>     source_table     IN VARCHAR2,<br>     old_value        IN VARCHAR2,<br>     new_value        IN VARCHAR2) as<br>--<br>-- Den Cursor zum Lesen der Datensätze aus<br>-- bbs_siteid_tables erstellen<br>-- Verwendung von *, um das Auslassen<br>-- einer Spalte zu verhindern<br>--<br>     CURSOR get_table_name IS<br>          SELECT<br>               *<br>          FROM<br>               bbs_update_tables<br>          WHERE<br>               main_table=source_table;<br>--<br>-- Variable vom Typ ROWTYPE für die Aufnahme eines<br>-- Datensatzes aus bbs_siteid_tables definieren.<br>-- Verwendung von ROWTYPE, um für zukünftige Änderungen<br>-- gewappnet zu sein.<br>--<br>     update_rec update_tables%ROWTYPE;<br>--<br>-- Verarbeitung beginnen<br>--<br>BEGIN<br>--<br>-- Cursor öffnen und Werte abrufen<br>--<br>   OPEN get_table_name;<br>   FETCH get_table_name INTO update_rec;<br>--<br>-- nun, da der Cursor geöffnet und die Werte in<br>-- Variablen eingelesen sind, kann die Schleife beginnen<br>--<br>
<hr>
<A name=9></a>LOOP<br>--<br>-- Unter Verwendung des Status NOTFOUND müssen wir den<br>-- Datensatz im Vorhinein füllen <br>--<br>   EXIT WHEN get_table_name%NOTFOUND;<br>--<br>-- Aufruf der Prozedur update_column initiieren<br>--<br>   update_column(old_value, new_value,<br>   update_rec.table_name, update_rec.column_name);<br>--<br>-- Nun wird der nächste Datensatz aus der Tabelle abgerufen<br>--<br>   FETCH get_table_name INTO update_rec;<br>--<br>-- Verarbeitung kehrt zur Schleifenanweisung zurück<br>--<br> END LOOP;<br>--<br>-- Cursor schließen und beenden<br>--<br> CLOSE get_table_name;<br>--<br>-- ENDE DER PROZEDUR<br>--<br>END update_tables;<br>--<br>-- ENDE DES PAKETRUMPFES<br>--<br>END cascade_update;<br>/<br>
<i>Quellcode 4.1: Paket für die Aktualisierungsweitergabe</i><br>
<hr>
<A name=10></a>CREATE OR REPLACE PROCEDURE get_bfiles(<br>  bfile_dir in   VARCHAR2,<br>  bfile_lis in   VARCHAR2,<br>  bfile_int_dir  VARCHAR2)<br>AS<br>  cur        INTEGER;<br>  bfile_int  VARCHAR2(100);<br>  sql_com    VARCHAR2(2000);<br>  file_proc  INTEGER;<br>  file_hand  utl_file.file_type;<br>  file_buff  VARCHAR2(1022);<br>  file_type  VARCHAR2(4);<br>BEGIN<br>  bfile_int:=UPPER(bfile_int_dir);<br>  file_hand:=utl_file.fopen(bfile_dir,bfile_lis,'R');<br>  LOOP<br>  BEGIN<br>    utl_file.get_line(file_hand,file_buff);<br>    cur:=dbms_sql.open_cursor;<br>    file_type:=SUBSTR(file_buff,INSTR(file_buff,'.')+1,3);<br>    file_type:=UPPER(file_type);<br>    IF file_type='GIF'<br>      THEN<br>       file_type:='GIF';<br>      ELSIF file_type='JPG'<br>        THEN file_type:='JPEG';<br>    END IF;<br>    sql_com:= 'INSERT INTO graphics_table '||CHR(10)||<br>              'VALUES (graphics_table_seq.NEXTVAL,'||CHR(39)||CHR(39)||<br>              ', bfilename('||<br>              CHR(39)||bfile_int||CHR(39)||','<br>              ||CHR(39)||file_buff||CHR(39)||<br>              ') ,'||CHR(39)||file_type||CHR(39)||')';<br>    dbms_output.put_line(sql_com);<br>    dbms_sql.parse(cur,sql_com,dbms_sql.v7);<br>    file_proc:=dbms_sql.execute(cur);<br>    dbms_sql.close_cursor(cur);<br>    EXCEPTION<br>      WHEN no_data_found THEN<br>        EXIT;<br>    END;<br>  END LOOP;<br>  utl_file.fclose(file_hand);<br>END;<br>/<br>
<i>Quellcode 4.2: Beispiel für eine Prozedur zum Einlesen eines </i>BFILE<br>
<hr>
<A name=11></a>CREATE OR REPLACE PROCEDURE load_lob AS<br>  id         NUMBER;<br>  image1     BLOB;<br>  locator    BFILE;<br>  bfile_len  NUMBER;<br>  bf_desc    VARCHAR2(30);<br>  bf_name    VARCHAR2(30);<br>  bf_dir     VARCHAR2(30);<br>  bf_typ     VARCHAR2(4);<br>  ctr        INTEGER;<br>CURSOR get_id IS<br>SELECT bfile_id,bfile_desc,bfile_type<br>FROM graphics_table;<br>BEGIN<br>  open get_id;<br> LOOP<br>   FETCH get_id INTO id, bf_desc, bf_typ;<br>   EXIT WHEN get_id%notfound;<br>   dbms_output.put_line('ID: '||to_char(id));<br>   SELECT bfile_loc<br>     INTO locator<br>     FROM graphics_table<br>     WHERE bfile_id=id;<br>   dbms_lob.filegetname(locator,bf_dir,bf_name);<br>   dbms_output.put_line('Dir: '||bf_dir);<br>   dbms_lob.fileopen(locator,dbms_lob.file_readonly);<br>   bfile_len:=dbms_lob.getlength(locator);<br>   dbms_output.put_line('ID: '||to_char(id)||' length: '||<br>     to_char(bfile_len));<br>   insert into dual_lob(x) values(empty_blob());<br>   select x into image1 from dual_lob;<br>   bfile_len:=dbms_lob.getlength(locator);<br>   dbms_lob.loadfromfile(image1,locator,bfile_len,1,1);<br>   IF bf_desc is null THEN<br>     bf_desc:=bf_name;<br>   END IF;<br>   insert into internal_graphics values (id,bf_desc,image1,bf_typ,'GENERAL');<br>   dbms_output.put_line(bf_desc||' Length: '||to_char(bfile_len)||<br>     ' Name: '||bf_name||' Dir: '||bf_dir||' '||bf_typ);<br>   dbms_lob.fileclose(locator);<br>   delete dual_lob;<br> END LOOP;<br>END load_lob;<br>
<i>Quellcode 4.3: Beispiel für eine PL/SQL-Prozedur zum Verschieben von </i>BFILEs<i> in </i>BLOBs<br>
<hr>
<A name=12></a>-- You may need to comment out the write_out procedure and<br>-- subsequenz calls to it, I like to track what tables need<br>-- analysis using a dba_running_stats table<br>--<br>CREATE OR REPLACE PROCEDURE check_tables (<br>   owner_name in varchar2,<br>   pchng IN NUMBER,<br>   lim_rows IN NUMBER) AS<br>--<br>CURSOR get_tab_count (own varchar2) IS<br>   SELECT table_name, nvl(num_rows,1)<br>   FROM dba_tables<br>   WHERE owner = upper(own);<br>--<br>tab_name    VARCHAR2(64);<br>rows        NUMBER;<br>string      VARCHAR2(255);<br>cur         INTEGER;<br>ret         INTEGER;<br>row_count   NUMBER;<br>com_string  VARCHAR2(255);<br>--<br>PROCEDURE write_out(<br>  par_name  IN VARCHAR2,<br>  par_value IN NUMBER,<br>  rep_ord   IN NUMBER,<br>  m_date    IN DATE,<br>  par_delta IN NUMBER) IS<br> BEGIN<br>   INSERT INTO dba_running_stats VALUES(<br>   par_name,par_value,rep_ord,m_date,par_delta );<br> END;<br>--<br>BEGIN<br>--<br>-- The next line is for schemas with many tables<br>-- If you don't lose the cursors you can exceed<br>-- open_cursor limits and flood the shared pool<br>--<br>DBMS_SESSION.SET_CLOSE_CACHED_OPEN_CURSORS(TRUE);<br>OPEN get_tab_count (owner_name);<br>LOOP<br>BEGIN<br>  FETCH get_tab_count INTO tab_name, rows;<br>  tab_name:=owner_name||'.'||tab_name;<br>  IF rows=0 THEN<br>    rows:=1;<br>  END IF;<br>EXIT WHEN get_tab_count%NOTFOUND;<br>DBMS_OUTPUT.PUT_LINE('Table name: '||tab_name||' rows: '||to_char(rows));<br>--<br>-- Need to have created the get_count procedure in the same schema<br>--<br>GET_COUNT(tab_name,row_count);<br>  IF row_count=0 THEN<br>    row_count:=1;<br>  END IF;<br>DBMS_OUTPUT.PUT_LINE('Row count for '||tab_name||': '||to_char(row_count));<br>DBMS_OUTPUT.PUT_LINE('Ratio: '||to_char(row_count/rows));<br>   IF (row_count/rows)&gt;1+(pchng/100) OR (rows/row_count)&gt;1+(pchng/100)<br>   THEN<br>     BEGIN<br>       IF (row_count&lt;lim_rows) THEN<br>         string :=<br>           'ANALYZE TABLE '||tab_name||' COMPUTE STATISTICS ';<br>
<hr>
<A name=13></a>       ELSE<br>         string :=<br>           'ANALYZE TABLE '||tab_name||' ESTIMATE STATISTICS SAMPLE 30 PERCENT';<br>       END IF;<br>       cur := DBMS_SQL.OPEN_CURSOR;<br>       DBMS_OUTPUT.PUT_LINE('Beginning analysis');<br>       DBMS_SQL.PARSE(cur,string,dbms_sql.v7);<br>       ret := DBMS_SQL.EXECUTE(cur);<br>       DBMS_SQL.CLOSE_CURSOR(cur);<br>       DBMS_OUTPUT.PUT_LINE(' Table: '||tab_name||' had to be analyzed.');<br>       write_out(' Table: '||tab_name||' had to be analyzed.', row_count/<br>                   rows,33,sysdate,0);<br>       EXCEPTION<br>       WHEN OTHERS THEN<br>         raise_application_error(-20002,'Error in analyze: '||to_char(sqlcode)||'<br>                                  on '||tab_name,TRUE);<br>         write_out(' Table: '||tab_name||' error during analyze.<br>                    '||to_char(sqlcode), row_count/rows,33,sysdate,0);<br>         IF dbms_sql.is_open(cur) THEN<br>           dbms_sql.close_cursor(cur);<br>         END IF;<br>       END;<br>     END IF;<br>  EXCEPTION<br>  WHEN others THEN<br>  null;<br>END;<br>COMMIT;<br>END LOOP;<br>CLOSE get_tab_count;<br>END;<br>
<i>Quellcode 4.4: Prozedur zum bedingten Analysieren von Tabellen</i><br>
<hr>
<A name=14></a>ACCEPT owner PROMPT 'Enter table owner name: '<br>ACCEPT table PROMPT 'Enter table name: '<br>SET HEADING OFF FEEDBACK OFF VERIFY OFF ECHO OFF RECSEP OFF PAGES 0<br>DEFINE cr = 'chr(10)'<br>SPOOL index_sz.sql<br>SELECT 'CREATE TABLE stat_temp AS SELECT * FROM index_stats WHERE<br>orwnum&lt;1;'||&amp;&amp;cr<br>FROM dual;<br>SELECT<br>'ANALYZE INDEX '||owner||'.'||index_name||' VALIDATE STRUCTURE;'||&amp;&amp;cr||<br>'INSERT INTO stat_temp SELECT * FROM index_stats;'||&amp;&amp;cr||<br>'COMMIT;'<br>FROM dba_indexes<br>WHERE owner=upper('&amp;owner')<br>AND table_name=upper('&amp;table');<br>SPOOL OFF<br>@index_sz.sql<br>
<i>Quellcode 6.1: Codefragment für die Analyse aller Tabellenindices eines Besitzers</i><br>
<hr>
<A name=15></a>rem *****************************************************************<br>rem<br>rem NAME: brown.sql<br>rem<br>rem HISTORY:<br>rem Date Who What<br>rem -------- ---------- ---------------------------<br>rem 06/05/97 Mike Ault Updated for Oracle 7.x<br>rem 09/27/99 Mike Ault Verified for 8.x<br>rem 09/22/99 Mike Ault Verified for 9.x<br>rem FUNCTION: Will show index browning for all indexes for a<br>rem user.<br>rem INPUTS: owner = Table owner name.<br>Rem<br>*********************************************************************<br>
column value noprint new_value blocksize<br>define cr=chr(10)<br>select value from v$parameter where name='db_block_size';<br>accept tab_owner prompt 'Enter Table Owner for Indexes:'<br>set heading off verify off termout off pages 0 recsep 0 feedback off<br>spool index_sz.sql<br>select<br>     'create table stat_temp as select * from index_stats;'||&amp;&amp;cr||<br>     'truncate table stat_temp;'<br>from dual;<br>select<br>     'analyze index '||owner||'.'||index_name||<br>     ' validate structure;'||&amp;&amp;cr||<br>     'insert into stat_temp select * from index_stats;'||&amp;&amp;cr||<br>     'commit;'<br>from dba_indexes<br>where<br>     owner=upper('&amp;&amp;tab_owner');<br>spool off<br>set feedback on termout on lines 80<br>start index_sz.sql<br>insert into temp_size_table select name,trunc(used_space/&amp;&amp;blocksize)<br>from stat_temp;<br>rem drop table stat_temp;<br>clear columns<br>column del_lf_rows_len format 999,999,999 heading 'Deleted Bytes'<br>column lf_rows_len format 999,999,999 heading 'Filled Bytes'<br>column browning format 999.90 heading 'Percent|Browned'<br>start ttitle &quot;Index Browning Report&quot;<br>spool rep_out/browning.lst<br>select<br>     name,del_lf_rows_len,lf_rows_len,<br>     (del_lf_rows_len/decode((lf_rows_len+del_lf_rows_len),0,1,<br>     lf_rows_len+del_lf_rows_len))*100 browning<br>from<br>     stat_temp<br>where<br>     del_lf_rows_len&gt;0;<br>spool off<br>
<i>Quellcode 6.2: Verfallsbericht für Indices</i><br>
<hr>
<A name=16></a>rem ******************************************************<br>rem NAME: IN_ES_SZ.sql<br>rem HISTORY:<br>rem Date           Who                     What<br>rem ---------------- ------------------------------------ --------<br>--------------------<br>rem 01/20/93       Michael Brouillette     Creation<br>rem 09/22/01       Michael Ault            Upgraded to 9i<br>rem FUNCTION:   Compute the space used by an entry for an<br>rem             existing index.<br>rem NOTES:      Currently requires DBA.<br>rem INPUTS:<br>rem        tname  = Name of table.<br>rem        towner = Name of owner of table.<br>rem        clist  = List of columns enclosed in quotes.<br>rem                 i.e., 'ename', 'empno'<br>rem        cfile  = Name of output SQL Script file<br>rem ******************************************************<br>COLUMN name     NEW_VALUE     db NOPRINT<br>COLUMN dum1     NOPRINT<br>COLUMN isize    FORMAT 99,999.99<br>COLUMN rcount   FORMAT 999,999,999 NEWLINE<br>ACCEPT tname  PROMPT 'Enter table name: '<br>ACCEPT towner PROMPT 'Enter table owner name: '<br>ACCEPT clist  PROMPT 'Enter column list: '<br>ACCEPT cfile  PROMPT 'Enter name for output SQL file: '<br>SET HEADING OFF VERIFY OFF TERMOUT OFF PAGES 0 EMBEDDED ON<br>SET FEEDBACK OFF SQLCASE UPPER TRIMSPOOL ON SQLBL OFF<br>SET NEWPAGE 3<br>SELECT name FROM v$database;<br>SPOOL rep_out/&amp;db/&amp;cfile..sql<br>SELECT -1 dum1,<br>       'SELECT ''Proposed Index on table ''||'<br>  FROM dual<br>UNION<br>SELECT 0,<br>       '''&amp;towner..&amp;tname'||' has '',COUNT(*) rcount,<br>       '' entries of '', ('<br>  FROM dual<br>UNION<br>SELECT column_id,<br>       'SUM(NVL(vsize('||column_name||'),0)) + 1 +'<br>  FROM dba_tab_columns<br> WHERE table_name = '&amp;tname'<br>   AND owner = '&amp;towner'<br>   AND column_name in (upper(&amp;clist))<br>   AND column_id &lt;&gt; (SELECT MAX(column_id)<br>                       FROM dba_tab_columns<br>                      WHERE table_name = UPPER('&amp;tname')<br>                        AND owner = UPPER('&amp;towner')<br>                        AND column_name IN (upper(&amp;clist)))<br>UNION<br>SELECT column_id,<br>       'SUM(NVL(VSIZE('||column_name||'),0)) + 1)'<br>  FROM dba_tab_columns<br> WHERE table_name = upper('&amp;tname')<br>   AND owner = upper('&amp;towner') AND column_name IN (upper(&amp;clist))<br>   AND column_id = (SELECT MAX(column_id)<br>                      FROM dba_tab_columns<br>                     WHERE table_name = upper('&amp;tname')<br>                       AND owner = upper('&amp;towner')<br>                       AND column_name IN (upper(&amp;clist)))<br>UNION<br>SELECT 997, '/ COUNT(*) + 11 isize, '' bytes each.'''<br>  FROM dual<br>
<hr>
<A name=17></a>UNION<br>SELECT 999, 'FROM &amp;towner..&amp;tname.;' FROM dual;<br>SPOOL OFF<br>SET TERMOUT ON FEEDBACK 15 PAGESIZE 20 SQLCASE MIXED<br>SET NEWPAGE 1<br>START rep_out/&amp;db/&amp;cfile<br>CLEAR COLUMNS<br>
<i>Quellcode 6.3: Skript zur Berechnung des erforderlichen Platzes für einen geplanten Index</i><br>
<hr>
<A name=18></a>rem *******************************************************<br>rem<br>rem NAME: IN_CM_SZ.sql<br>rem<br>rem HISTORY:<br>rem Date             Who           What<br>rem ---------------- ------------- ----------------<br>rem 01/20/93  Michael Brouillette  Creation<br>rem 09/22/01  Mike Ault            Updated to 9i<br>rem<br>rem FUNCTION: Compute the space used by an entry for an<br>rem           existing index.<br>Rem<br>rem NOTES:    Currently requires DBA.<br>Rem<br>rem INPUTS:<br>rem        tname  = Name of table.<br>rem        towner = Name of owner of table.<br>rem        iname  = Name of index.<br>rem        iowner = Name of owner of index.<br>rem        cfile  = Name of output file SQL Script.<br>rem *******************************************************<br>COLUMN dum1       NOPRINT<br>COLUMN isize      FORMAT 999,999,999.99<br>COLUMN rcount     FORMAT 999,999,999 NEWLINE<br>ACCEPT tname  PROMPT 'Enter table name: '<br>ACCEPT towner PROMPT 'Enter table owner name: '<br>ACCEPT iname  PROMPT 'Enter index name: '<br>ACCEPT iowner PROMPT 'Enter index owner name: '<br>ACCEPT cfile  PROMPT 'Enter name for output SQL file: '<br>SET PAGESIZE 0 HEADING OFF VERIFY OFF TERMOUT OFF<br>SET FEEDBACK OFF TRIMSPOOL ON SQLBL OFF<br>SET SQLCASE UPPER NEWPAGE 3<br>SPOOL &amp;cfile..sql<br>SELECT -1 dum1,<br>       'SELECT ''Index '||'&amp;iowner..&amp;iname'||' on table '<br>  FROM dual<br>UNION<br>SELECT 0,<br>       '&amp;towner..&amp;tname'||' has '',<br>       nvl(COUNT(*),0) rcount,'' entries of '', ('<br>  FROM dual<br>UNION<br>SELECT column_id,<br>       'SUM(NVL(vsize('||column_name||'),0)) + 1 +'<br>  FROM dba_tab_columns<br> WHERE table_name = '&amp;tname'<br>   AND owner = upper('&amp;towner') AND column_name IN<br>                   (SELECT column_name FROM dba_ind_columns<br>                     WHERE table_name = upper('&amp;tname')<br>                       AND table_owner = upper('&amp;towner')<br>                       AND index_name = upper('&amp;iname')<br>                       AND index_owner = upper('&amp;iowner'))<br>                       AND column_id &lt;&gt; (select max(column_id)<br>                                         FROM dba_tab_columns<br>                                        WHERE table_name = upper('&amp;tname')<br>                                          AND owner = upper('&amp;towner')<br>                                          AND column_name IN<br>                   (SELECT column_name FROM dba_ind_columns<br>                     WHERE table_name = upper('&amp;tname')<br>                       AND table_owner = upper('&amp;towner')<br>                       AND index_name = upper('&amp;iname')<br>                       AND index_owner = upper('&amp;iowner')))<br>UNION<br>SELECT column_id,<br>
<hr>
<A name=19></a>       'SUM(NVL(vsize('||column_name||'),0)) + 1)'<br>  FROM dba_tab_columns<br> WHERE table_name = upper('&amp;tname') AND owner = upper('&amp;towner')<br>   AND column_name IN<br>                   (SELECT column_name FROM dba_ind_columns<br>                     WHERE table_name = upper('&amp;tname')<br>                       AND table_owner = upper('&amp;towner')<br>                       AND index_name = upper('&amp;iname')<br>                       AND index_owner = upper('&amp;iowner'))<br>                       AND column_id = (SELECT MAX(column_id)<br>                      FROM dba_tab_columns<br>                     WHERE table_name = upper('&amp;tname')<br>                       AND owner = upper('&amp;towner')<br>                       AND column_name IN<br>                       (SELECT column_name FROM dba_ind_columns<br>                         WHERE table_name = upper('&amp;tname')<br>                           AND table_owner = upper('&amp;towner')<br>                           AND index_name = upper('&amp;iname')<br>                           AND index_owner = upper('&amp;iowner')))<br>UNION<br>SELECT 997,<br>       '/ COUNT(*) + 11 isize, '' bytes each.''' from dual<br>UNION<br>SELECT 999, 'FROM &amp;towner..&amp;tname.;' FROM dual;<br>SPOOL OFF<br>SET TERMOUT ON FEEDBACK 15 PAGESIZE 20 SQLCASE MIXED<br>SET NEWPAGE 1<br>START &amp;cfile<br>CLEAR columns<br>UNDEF tname<br>UNDEF towner<br>UNDEF iname<br>UNDEF iowner<br>UNDEF cfile<br>
<i>Quellcode 6.4: Skript zur Berechnung der durchschnittlichen Länge eines Indexeintrags</i><br>
<hr>
<A name=20></a>REM FUNCTION : SCRIPT FOR CREATING SYNONYMS<br>REM       This script must be run by a user with the DBA role.<br>REM       This script is intended to run with Oracle7 or Oracle8.<br>REM       Running this script will in turn create a script to build<br>REM       all the synonyms in the database. The created script,<br>REM       create_synonyms.sql, can be run by any user with the DBA<br>REM       role or with the 'CREATE ANY SYNONYM' and 'CREATE PUBLIC<br>REM       SYNONYM' system privileges.<br>REM NOTE: This script does not capture synonyms for tables<br>REM       owned by the 'SYS' user.<br>REM       Only preliminary testing of this script was performed.<br>REM       Be sure to test it completely before relying on it.<br>REM<br>SET VERIFY OFF FEEDBACK OFF TERMOUT OFF ECHO OFF PAGESIZE 0<br>SET TERMOUT ON<br>SELECT ''Creating synonym build script...'' FROM dual;<br>SET TERMOUT OFF<br>COLUMN dbname NEW_VALUE db NOPRINT<br>SELECT name dbname FROM v$database;<br>DEFINE cr=''chr(10)''<br>SPOOL rep_out\&amp;db\crt_syns.sql<br>
SELECT ''CREATE ''|| DECODE(owner,''PUBLIC'',''PUBLIC '',NULL) ||<br>     'SYNONYM ''|| DECODE(owner,''PUBLIC'',NULL, owner || ''.'') ||<br>     LOWER(synonym_name) || '' FOR '' || LOWER(table_owner) ||<br>     ''.'' || LOWER(table_name) ||<br>     DECODE(db_link,NULL,NULL,''@''||db_link) || '';''<br> FROM sys.dba_synonyms<br> WHERE table_owner != ''SYS''<br> ORDER BY owner<br>/<br>SPOOL OFF<br>SET VERIFY ON FEEDBACK ON TERMOUT ON PAGESIZE 22<br>CLEAR COLUMNS<br>UNDEF cr<br>
<i>Quellcode 7.1: Skript zur Generierung eines Skripts für die erneute Erstellung von Synonymen</i><br>
<hr>
<A name=21></a>CREATE VIEW free_space<br>(tablespace, file_id, pieces, free_bytes, free_blocks,<br>largest_bytes,largest_blks) AS<br>SELECT tablespace_name, file_id, COUNT(*),<br>     SUM(bytes), SUM(blocks),<br>     MAX(bytes), MAX(blocks) FROM sys.dba_free_space<br> GROUP BY tablespace_name, file_id;<br>
<i>Quellcode 7.2: Beispiel für eine Sicht mit Ausdrücken</i><br>
<hr>
<A name=22></a>REM Title       : DD_VIEW.SQL<br>REM Purpose     : View of the Data Dictionary caches<br>REM               showing only parameters that have usage<br>REM               and the percent of GETMISSES/GETS<br>REM USE         : Use as a selectable table only<br>REM Limitations : User must have access to V$ views.<br>REM Revisions   :<br>REM   Date     Modified By   Reason For change<br>REM   4/28/93  Mike Ault     Initial Creation<br>REM<br>CREATE VIEW dd_cache<br>AS SELECT parameter,gets,getmisses,<br>getmisses/gets*100 percent<br>,count,usage<br>FROM v$rowcache<br>WHERE gets &gt; 100 AND getmisses &gt; 0;<br>
<i>Quellcode 7.3: Beispiel für eine Sicht mit Ausdrücken und Filterregel</i><br>
<hr>
<A name=23></a>REM<br>REM NAME        : view_rct.sql<br>REM FUNCTION    : re-create database views by owner<br>REM USE         : Generate a report on database views<br>REM Limitations : If your view definitions are greater than 5000<br>REM               characters then increase the set long. This can<br>REM               be determined by querying the DBA_VIEWS table's<br>REM               text_length column for the max value: select<br>REM               max(text_length) from dba_views;<br>REM<br>SET PAGES 59 LINES 79 FEEDBACK OFF ECHO OFF VERIFY <br>OFF<br>DEFINE cr='chr(10)'<br>COLUMN text       FORMAT a80 word_wrapped<br>COLUMN view_name  FORMAT a20<br>COLUMN dbname NEW_VALUE db NOPRINT<br>UNDEF owner_name<br>UNDEF view_name<br>SELECT name dbname from v$database;<br>SET LONG 5000 HEADING OFF<br>SPOOL rep_out\&amp;db\cre_view.sql<br>SELECT<br>     'rem Code for view: '||v.view_name||'instance: '||&amp;&amp;db||&amp;&amp;cr||<br>     'CREATE OR REPLACE VIEW '||v.owner||'.'||v.view_name||' AS '<br>     ||&amp;&amp;cr,<br>     v.text<br> FROM<br>     dba_views v<br> WHERE<br>     v.owner LIKE UPPER('&amp;&amp;owner_name%')<br>     AND view_name LIKE UPPER('%&amp;&amp;view_name%')<br> ORDER BY<br>     v.view_name;<br>SPOOL OFF<br>SET HEADING ON PAGES 22 LINES 80 FEEDBACK ON<br>CLEAR COLUMNS<br>TTITLE OFF<br>PAUSE Press enter to continue<br>
<i>Quellcode 7.4: Skript zur Neuerstellung von Sichten</i><br>
<hr>
<A name=24></a>CREATE SNAPSHOT new_drugs<br>PCTFREE 10 PCTUSED 70<br>TABLESPACE clinical_tests<br>STORAGE (INITIAL 50K NEXT 50K PCTINCREASE 0)<br>REFRESH<br>START WITH ROUND(SYSDATE + 7) + 2/24<br>NEXT NEXT_DAY(TRUNC(SYSDATE, 'TUESDAY') + 2/24<br>AS SELECT * FROM appl_dba.test_drugs@kcgc<br>
<i>Quellcode 7.5: Beispielskript für den </i>CREATE SNAPSHOT<i>-Befehl mit einem einfachen Snapshot</i><br>
<hr>
<A name=25></a>CREATE SNAPSHOT trial_summary<br>PCTFREE 5 PCTUSED 60<br>TABLESPACE clinical_tests<br>STORAGE (INITIAL 100K NEXT 50K PCTINCREASE 0)<br>REFRESH COMPLETE<br>START WITH ROUND(SYSDATE + 14) + 6/24<br>NEXT NEXT_DAY(TRUNC(SYSDATE, 'FRIDAY') + 19/24<br>AS<br>SELECT<br>     td.drug_name, s.trial_number, dr.doctor_id,<br>     s.comment_line,s.comment<br> FROM<br>     appl_dba.test_drugs@kcgc td,<br>     appl_dba.trial_doctors@kcgc dr,<br>     appl_dba.trial_summaries@kcgc s<br> WHERE<br>     td.drug_id = s.drug_id and<br>     s.trial_id = dr.trial_id and<br>     s.doctor_id = dr.doctor_id;<br>
<i>Quellcode 7.6: Beispielskript für den </i>CREATE SNAPSHOT<i>-Befehl mit einem komplexen Snapshot</i><br>
<hr>
<A name=26></a>rem Name    : inv_obj.sql<br>rem Purpose : Show all invalid objects in database<br>rem Mike Ault 7/2/96 TUSC<br>rem<br>COLUMN object_name  FORMAT A30 HEADING 'Object|Name'<br>COLUMN owner        FORMAT a10 HEADING 'Object|Owner'<br>COLUMN last_time    FORMAT a20 HEADING 'Last Change|Date'<br>SET LINES 80 FEEDBACK OFF PAGES 0 VERIFY OFF<br>START title80 'Invalid Database Objects'<br>SPOOL rep_out/&amp;db/inv_obj<br>SELECT<br>     owner,<br>     object_name,<br>     object_type,<br>     TO_CHAR(last_ddl_time,'DD-MON-YY hh:mi:ss') Last_time<br>FROM<br>     dba_objects<br>WHERE<br>     status='INVALID'<br>/<br>PAUSE Press Enter to continue<br>SET LINES 80 FEEDBACK ON PAGES 22 VERIFY ON<br>CLEAR COLUMNS<br>TTITLE OFF<br>
<i>Quellcode 7.7: Beispielskript zur Überprüfung des Status von Datenbankobjekten</i><br>
<hr>
<A name=27></a>rem *****************************************************<br>rem NAME     : FPRC_RCT.sql<br>rem FUNCTION : Build a script to re-create functions,<br>rem            procedures, packages, or package bodies.<br>rem HISTORY  :<br>rem Date      Who           What<br>rem --------  ------------  ------------------------<br>rem 05/22/93  Michael Ault  Created<br>rem *******************************************************<br>SET VERIFY OFF FEEDBACK OFF LINES 80 PAGES 0 HEADING OFF<br>SPOOL cre_fprc.sql<br>SELECT 'CREATE '||s1.type||' '||s1.owner||'.'||s1.name,<br>substr(s2.text,1,80)||';'<br> FROM<br>     dba_source s1,<br>     dba_source s2<br> WHERE<br>     s1.type = UPPER('&amp;object_type') AND<br>     s1.owner = UPPER('&amp;object_owner') AND<br>     s1.type = s2.type AND<br>     s1.owner = s2.owner AND<br>     s1.name = UPPER('&amp;object_name') AND<br>     s1.name = s2.name<br> GROUP BY<br>     s1.owner,<br>     s1.name<br> ORDER BY<br>     s2.line;<br>rem<br>SPOOL OFF<br>
<i>Quellcode 7.8: Beispielskript zur erneuten Erstellung  von Funktionen, Prozeduren und Paketobjekten</i><br>
<hr>
<A name=28></a>CREATE OR REPLACE PROCEDURE BODY admin.employee_package AS<br>FUNCTION new_emp(ename CHAR, position CHAR, supervisor NUM,<br>category NUM, hiredate DATE)<br>RETURN NUMBER IS<br>emp_number number(5);<br>BEGIN<br>     .<br>     .<br>     .<br>END;<br>FUNCTION fire_them(<br>ename CHAR,reason VARCHAR2,term_date DATE)<br>RETURN NUMBER AS<br>years_of_service NUMBER (4,2);<br>BEGIN<br>     .<br>     .<br>     .<br>END;<br>PROCEDURE new_dept(ename CHAR, dept CHAR, new_dept CHAR,<br>date_of_change DATE)<br>IS<br>BEGIN<br>     .<br>     .<br>     .<br>END;<br>END employee_package<br>
<i>Quellcode 7.9: Beispielformat für einen Paketrumpf</i><br>
<hr>
<A name=29></a>s<br>
set echo on<br>spool test_resource_plan.doc<br>-- Grant system privilege to plan administrator<br>--<br>execute<br>dbms_resource_manager_privs.grant_system_privilege('SYSTEM','ADMINISTER_RESOURCE_<br>MANAGER',TRUE);<br>--<br>--connect to plan administrator<br>--<br>CONNECT system/system_test@ortest1.world<br>--<br>-- Create Plan Pending Area<br>--<br>EXECUTE dbms_resource_manager.create_pending_area();<br>--<br>-- Create plan<br>--<br>execute dbms_resource_manager.create_plan('MASTER','Example Resource<br>Plan','EMPHASIS');<br>execute dbms_resource_manager.create_plan('USERS','Example Resource Sub<br>Plan','EMPHASIS');<br>execute dbms_resource_manager.create_plan('REPORTS','Example Resource Sub<br>Plan','EMPHASIS');<br>--<br>--Create tiers of groups in plan<br>--<br>EXECUTE dbms_resource_manager.create_consumer_group('ONLINE_USERS','3rd level<br>group','ROUND-ROBIN');<br>EXECUTE dbms_resource_manager.create_consumer_group('BATCH_USERS','3rd level<br>group','ROUND-ROBIN');<br>EXECUTE dbms_resource_manager.create_consumer_group('ONLINE_REPORTS','2nd<br>level group','ROUND-ROBIN');<br>EXECUTE dbms_resource_manager.create_consumer_group('BATCH_REPORTS','2nd<br>level group','ROUND-ROBIN');<br>--<br>-- Create plan directives<br>--<br>EXECUTE dbms_resource_manager.create_plan_directive('MASTER', 'USERS',<br>0,60,0,0,0,0,0,0,NULL);<br>EXECUTE dbms_resource_manager.create_plan_directive('MASTER', 'REPORTS',<br>0,20,0,0,0,0,0,0,NULL);<br>EXECUTE dbms_resource_manager.create_plan_directive('MASTER','OTHER_GROUPS',<br>0,20,0,0,0,0,0,0,NULL);<br>EXECUTE dbms_resource_manager.create_plan_directive('USERS', 'ONLINE_USERS',<br>0,0,70,0,0,0,0,0,NULL);<br>EXECUTE dbms_resource_manager.create_plan_directive('USERS', 'BATCH_USERS',<br>0,0,30,0,0,0,0,0,NULL);<br>EXECUTE<br>dbms_resource_manager.create_plan_directive('REPORTS','ONLINE_REPORTS',0,0,70<br>,0,0,0,0,0,NULL);<br>EXECUTE<br>dbms_resource_manager.create_plan_directive('REPORTS','BATCH_REPORTS',<br>0,0,30,0,0,0,0,0,NULL);<br>--<br>-- Verify Plan<br>--<br>EXECUTE dbms_resource_manager.validate_pending_area;<br>--<br>-- Submit Plan<br>--<br>EXECUTE dbms_resource_manager.submit_pending_area;<br>spool off<br>set echo off<br>
<i>Quellcode 9.1: Skript zum Erstellen eines beispielhaften Ressourcenplans</i><br>
SQL&gt; -- Grant system privilege to plan administrator<br>
<hr>
<A name=30></a>SQL&gt; --<br>SQL&gt; execute<br>dbms_resource_manager_privs.grant_system_privilege('SYSTEM','ADMINISTER_RESOU<br>RCE_MANAGER',TRUE);<br>
PL/SQL procedure successfully completed.<br>
SQL&gt; --<br>SQL&gt; --connect to plan administrator<br>SQL&gt; --<br>SQL&gt; CONNECT system/system_test@ortest1.world<br>
Connected.<br>
SQL&gt; --<br>SQL&gt; -- Create Plan Pending Area<br>SQL&gt; --<br>SQL&gt; EXECUTE dbms_resource_manager.create_pending_area();<br>
PL/SQL procedure successfully completed.<br>
SQL&gt; --<br>SQL&gt; -- Create plan<br>SQL&gt; --<br>SQL&gt; execute dbms_resource_manager.create_plan('MASTER','Example Resource<br>Plan','EMPHASIS');<br>
PL/SQL procedure successfully completed.<br>
SQL&gt; execute dbms_resource_manager.create_plan('USERS','Example Resource Sub<br>Plan','EMPHASIS');<br>
PL/SQL procedure successfully completed.<br>
SQL&gt; execute dbms_resource_manager.create_plan('REPORTS','Example Resource<br>Sub Plan','EMPHASIS');<br>
PL/SQL procedure successfully completed.<br>
SQL&gt; --<br>SQL&gt; --Create tiers of groups in plan<br>SQL&gt; --<br>SQL&gt; EXECUTE dbms_resource_manager.create_consumer_group('ONLINE_USERS','3rd<br>level group','ROUND-ROBIN');<br>
PL/SQL procedure successfully completed.<br>
SQL&gt; EXECUTE dbms_resource_manager.create_consumer_group('BATCH_USERS','3rd<br>level group','ROUND-ROBIN');<br>
PL/SQL procedure successfully completed.<br>
SQL&gt; EXECUTE<br>dbms_resource_manager.create_consumer_group('ONLINE_REPORTS','2nd level<br>group','ROUND-ROBIN');<br>
PL/SQL procedure successfully completed.<br>
SQL&gt; EXECUTE dbms_resource_manager.create_consumer_group('BATCH_REPORTS','2nd<br>level group','ROUND-ROBIN');<br>
PL/SQL procedure successfully completed.<br>
SQL&gt; --<br>SQL&gt; -- Create plan directives<br>SQL&gt; --<br>SQL&gt; EXECUTE dbms_resource_manager.create_plan_directive('MASTER', 'USERS',<br>
<hr>
<A name=31></a>0,60,0,0,0,0,0,0,NULL);<br>
PL/SQL procedure successfully completed.<br>
SQL&gt; EXECUTE dbms_resource_manager.create_plan_directive('MASTER', 'REPORTS',<br>0,20,0,0,0,0,0,0,NULL);<br>
PL/SQL procedure successfully completed.<br>
SQL&gt; EXECUTE<br>dbms_resource_manager.create_plan_directive('MASTER','OTHER_GROUPS',<br>0,20,0,0,0,0,0,0,NULL);<br>
PL/SQL procedure successfully completed.<br>
SQL&gt; EXECUTE dbms_resource_manager.create_plan_directive('USERS',<br>'ONLINE_USERS', 0,0,70,0,0,0,0,0,NULL);<br>
PL/SQL procedure successfully completed.<br>
SQL&gt; EXECUTE dbms_resource_manager.create_plan_directive('USERS',<br>'BATCH_USERS', 0,0,30,0,0,0,0,0,NULL);<br>
PL/SQL procedure successfully completed.<br>
SQL&gt; EXECUTE<br>dbms_resource_manager.create_plan_directive('REPORTS','ONLINE_REPORTS',0,0,70<br>,0,0,0,0,0,NULL);<br>
PL/SQL procedure successfully completed.<br>
SQL&gt; EXECUTE<br>dbms_resource_manager.create_plan_directive('REPORTS','BATCH_REPORTS',<br>0,0,30,0,0,0,0,0,NULL);<br>
PL/SQL procedure successfully completed.<br>
SQL&gt; --<br>SQL&gt; -- Verify Plan<br>SQL&gt; --<br>SQL&gt; EXECUTE dbms_resource_manager.validate_pending_area;<br>
PL/SQL procedure successfully completed.<br>
SQL&gt; --<br>SQL&gt; -- Submit Plan<br>SQL&gt; --<br>SQL&gt; EXECUTE dbms_resource_manager.submit_pending_area;<br>
PL/SQL procedure successfully completed.<br>
SQL&gt; spool off<br>
<i>Listing 9.2: Beispiel für die Ausführung des Skripts zum Erstellen eines Ressourcenplans</i><br>
EXECUTE dbms_resource_manager.delete_plan('MASTER');<br>EXECUTE dbms_resource_manager.delete_plan('USERS');<br>EXECUTE dbms_resource_manager.delete_plan('REPORTS');<br>--<br>--delete tiers of groups in plan<br>--<br>EXECUTE dbms_resource_manager.delete_consumer_group('ONLINE_USERS');<br>EXECUTE dbms_resource_manager.delete_consumer_group('BATCH_USERS');<br>EXECUTE dbms_resource_manager.delete_consumer_group('ONLINE_REPORTS');<br>EXECUTE dbms_resource_manager.delete_consumer_group('BATCH_REPORTS');<br>
<i>Quellcode 9.2: Beispiel für eine Prozedur zum Löschen eines Ressourcenplans</i><br>
<hr>
<A name=32></a>CREATE OR REPLACE PACKAGE graphics_app AUTHID DEFINER AS<br>PROCEDURE get_graphics_function(usern IN VARCHAR2, graphics_function OUT<br>VARCHAR2);<br>PROCEDURE set_graphics_context(usern IN VARCHAR2);<br>END;<br>/<br>SET ARRAYSIZE 1<br>SHOW ERR<br>CREATE OR REPLACE PACKAGE BODY graphics_app AS<br>graphics_user VARCHAR2(32);<br>graphics_function VARCHAR2(32);<br>PROCEDURE get_graphics_function(usern IN VARCHAR2, graphics_function OUT<br>VARCHAR2) IS<br>BEGIN<br>SELECT user_function INTO graphics_function FROM graphics_dba.graphics_users<br>WHERE username=usern;<br>END get_graphics_function;<br>PROCEDURE set_graphics_context(usern IN VARCHAR2) IS<br>BEGIN<br>graphics_app.get_graphics_function(usern,graphics_function);<br>DBMS_SESSION.SET_CONTEXT('GRAPHICS_SEC','GRAPHICS_FUNCTION',graphics_function<br>);<br>DBMS_SESSION.SET_CONTEXT('GRAPHICS_SEC','GRAPHICS_USER',usern);<br>END set_graphics_context;<br>END graphics_app;<br>/<br>SHOW ERR<br>
<i>Quellcode 9.3: Beispiel für ein Paket zum Setzen des Kontextes</i><br>
<hr>
<A name=33></a>CREATE OR REPLACE TRIGGER set_graphics_context AFTER LOGON ON DATABASE<br>DECLARE<br>username VARCHAR2(30);<br>BEGIN<br>username:=SYS_CONTEXT('USERENV','SESSION_USER');<br>graphics_app.set_graphics_context(username);<br>EXCEPTION<br>WHEN OTHERS THEN<br>NULL;<br>END;<br>/<br>
<i>Quellcode 9.4: Beispiel für einen Anmeldungstrigger für die Datenbank</i><br>
CREATE OR REPLACE PACKAGE graphics_sec AUTHID DEFINER AS<br>FUNCTION graphics_check(obj_schema VARCHAR2, obj_name VARCHAR2)<br> RETURN VARCHAR2;<br>PRAGMA RESTRICT_REFERENCES(GRAPHICS_CHECK,WNDS);<br>END;<br>/<br>SET ARRAYSIZE 1<br>SHOW ERR<br>CREATE OR REPLACE PACKAGE BODY graphics_sec AS<br>FUNCTION graphics_check(obj_schema VARCHAR2, obj_name VARCHAR2)<br> RETURN VARCHAR2 AS<br>d_predicate VARCHAR2(2000);<br>user_context VARCHAR2(32);<br>BEGIN<br>  user_context:=SYS_CONTEXT('graphics_sec','graphics_function');<br>  IF user_context = 'ADMIN' THEN<br>    d_predicate:=' 1=1';<br>dbms_output.put_line(d_predicate);<br>  ELSIF user_context = 'GENERAL USER' THEN<br>    d_predicate:=' graphics_usage='||chr(39)||'UNRESTRICTED'||chr(39);<br>dbms_output.put_line(d_predicate);<br>  ELSIF user_context='DEVELOPER' THEN<br>    d_predicate:=' 1=1';<br>dbms_output.put_line(d_predicate);<br>  ELSIF user_context IS NULL THEN<br>    d_predicate:='1=2';<br>  END IF;<br>  RETURN d_predicate;<br>END graphics_check;<br>END;<br>/<br>SHOW ERR<br>
<i>Quellcode 9.5: Beispiel für ein Paket zur Kontextprüfung</i><br>
<hr>
<A name=34></a>REM<br>REM NAME        : TABLE.SQL<br>REM FUNCTION    : GENERATE TABLE REPORT<br>REM Limitations : None<br>clear COLUMNs<br>COLUMN owner             FORMAT a15    HEADING 'Table | Owner'<br>COLUMN table_name        FORMAT a18    HEADING Table<br>COLUMN tablespace_name   FORMAT A13    HEADING Tablespace<br>COLUMN pct_increase                    HEADING 'Pct|Increase'<br>COLUMN init                            HEADING 'Initial|Extent'<br>COLUMN next                            HEADING 'Next|Extent'<br>COLUMN partitioned       FORMAT a4     HEADING 'Par?'<br>COLUMN iot_type          FORMAT a4     HEADING 'Iot?'<br>COLUMN nested            FORMAT a5     HEADING 'Nest?'<br>COLUMN temporary         FORMAT a5     HEADING 'Temp?'<br>COLUMN extern            FORMAT a8     Heading 'External?'<br>BREAK ON owner ON tablespace_name<br>SET PAGES 48 LINES 132<br>START TITLE132 &quot;ORACLE TABLE REPORT&quot;<br>SPOOL rep_out\&amp;db\tab_rep<br>SELECT<br>     owner,<br>     tablespace_name,<br>     table_name,<br>     initial_extent Init,<br>     next_extent Next,<br>     pct_increase,<br>     partitioned,<br>     DECODE(iot_type,NULL,'No','Yes') iot_type,<br>     nested,<br>     DECODE(temporary,'N','No','Yes') temporary,<br>        DECODE(initial_extent, null,<br>              DECODE(iot_type,null,<br>              DECODE(temporary,'N','Yes')),'No') extern<br>FROM<br>     sys.dba_tables<br>WHERE<br>     owner NOT IN (<br>'SYSTEM','SYS','DBSNMP','AURORA$JIS$UTILITY$',<br>'AURORA$ORB$UNAUTHENTICATED','SCOTT','OSE$HTTP$ADMIN',<br>'OUTLN','LBACSYS','OE','QS','QS_CS','QS_CB','QS_CBADM',<br>'QS_OS','QS_ES','QS_WS','QS_ADM','SH','HR','WKSYS','ORDSYS',<br>'ORDPLUGINS','CTXSYS','MDSYS','PM')<br>ORDER BY<br>     owner,<br>     tablespace_name,<br>     table_name;<br>SPOOL OFF<br>CLEAR COLUMNS<br>PAUSE Press enter to continue<br>SET PAGES 22 LINES 80<br>TTITLE OFF<br>CLEAR COLUMNS<br>CLEAR BREAKS<br>
<i>Quellcode 10.1: Skript für einen Tabellenbericht</i><br>
<hr>
<A name=35></a>REM<br>REM NAME        : EXTENTS.SQL<br>REM FUNCTION    : GENERATE EXTENTS REPORT<br>REM USE         : FROM SQLPLUS OR OTHER FRONT END<br>REM LIMITATIONS : NONE<br>REM<br>CLEAR COLUMNS<br>COLUMN segment_name    HEADING 'Segment'     FORMAT A15<br>COLUMN tablespace_name HEADING 'Tablespace'  FORMAT A10<br>COLUMN owner           HEADING 'Owner'       FORMAT A10<br>COLUMN segment_type    HEADING 'Type'        FORMAT A10<br>COLUMN size            HEADING 'Size'        FORMAT 999,999,999<br>COLUMN extents         HEADING 'Current|Extents'<br>COLUMN max_extents     HEADING 'Max|Extents'<br>COLUMN bytes           HEADING 'Size|(Bytes)'<br>SET PAGESIZE 58 NEWPAGE 0 LINESIZE 130 FEEDBACK OFF<br>SET ECHO OFF VERIFY OFF<br>ACCEPT extents PROMPT 'Enter max number of extents: '<br>BREAK ON tablespace_name SKIP PAGE ON owner<br>START TITLE132 &quot;Extents Report&quot;<br>DEFINE output = rep_out\&amp;db\extent<br>SPOOL &amp;output<br>SELECT tablespace_name,<br>     segment_name,<br>     extents,<br>     max_extents,<br>     bytes,<br>     owner &quot;owner&quot;,<br>     segment_type<br>FROM  dba_segments<br>WHERE extents &gt;= &amp;extents AND owner LIKE UPPER('%&amp;owner%')<br>ORDER BY tablespace_name,owner,segment_type,segment_name;<br>SPOOL OFF<br>CLEAR COLUMNS<br>CLEAR BREAKS<br>SET TERMOUT ON FEEDBACK ON VERIFY ON<br>UNDEF extents<br>UNDEF owner<br>TTITLE OFF<br>UNDEF OUTPUT<br>PAUSE Press enter to continue<br>
<i>Quellcode 10.2: SQL*Plus-Bericht zum Anzeigen der Extents für jede Tabelle in jedem Tablespace</i><br>
<hr>
<A name=36></a>rem  *************************************************************<br>rem<br>rem  NAME: ACT_SIZE.sql<br>rem<br>rem  HISTORY:<br>rem  Date      Who                  What<br>rem  --------  -------------------- ---------------------------------<br>rem  09/??/90  Maurice C. Manton    Creation for IOUG<br>rem  12/23/92  Michael Brouillette  Assume TEMP_SIZE_TABLE exists.<br>rem                                 Use DBA info. Prompt for user<br>rem                                 name. Spool file = owner.<br>rem  07/15/96  Mike Ault        Updated for Oracle 7.x, added indexes<br>rem  06/12/97  Mike Ault        Updated for Oracle 8.x (use DBMS_ROWID)<br>rem  FUNCTION: Will show actual blocks used vs allocated for all tables<br>rem            for a user<br>rem  INPUTS:   owner = Table owner name.<br>rem  ************************************************************<br>ACCEPT owner PROMPT 'Enter table owner name: '<br>SET HEADING OFF FEEDBACK OFF VERIFY OFF ECHO OFF RECSEP OFF PAGES 0<br>COLUMN db_block_size NEW_VALUE blocksize NOPRINT<br>TTITLE OFF<br>DEFINE cr='chr(10)'<br>DEFINE qt='chr(39)'<br>TRUNCATE TABLE temp_size_table;<br>SELECT value db_block_size FROM v$parameter WHERE name='db_block_size';<br>SPOOL fill_sz.sql<br>SELECT<br>     'INSERT INTO temp_size_table'||&amp;&amp;cr||<br>     'SELECT '||&amp;&amp;qt||segment_name||&amp;&amp;qt||&amp;&amp;cr||<br>     ',COUNT(DISTINCT(dbms_rowid.rowid_block_number(rowid))) blocks'||&amp;&amp;cr||<br>     'FROM &amp;&amp;owner..'||segment_name, ';'<br> FROM<br>     dba_segments<br> WHERE<br>     segment_type ='TABLE'<br>     AND owner = UPPER('&amp;owner');<br>SPOOL OFF<br>SPOOL index_sz.sql<br>SELECT<br>     'CREATE TABLE stat_temp AS SELECT * FROM index_stats;'||&amp;&amp;cr||<br>     'TRUNCATE TABLE stat_temp;'<br> FROM<br>     dual;<br>SELECT<br>     'ANALYZE INDEX '||owner||'.'||index_name||' VALIDATE STRUCTURE;'||&amp;&amp;cr||<br>     'INSERT INTO stat_temp SELECT * FROM index_stats;'||&amp;&amp;cr||<br>     'COMMIT;'<br> FROM<br>     dba_indexes<br> WHERE<br>     owner=UPPER('&amp;owner');<br>SPOOL OFF<br>SET FEEDBACK ON TERMOUT ON LINES 132<br>START index_sz.sql<br>INSERT INTO temp_size_table SELECT name,trunc(used_space/&amp;&amp;blocksize)<br>FROM stat_temp;<br>DROP TABLE stat_temp;<br>DEFINE temp_var = &amp;&amp;qt;<br>START fill_sz<br>HOST rm fill_size_table.sql<br>DEFINE bs = '&amp;&amp;blocksize K'<br>COLUMN t_date      NOPRINT NEW_VALUE t_date<br>COLUMN user_id     NOPRINT NEW_VALUE user_id<br>COLUMN segment_name      FORMAT A25         HEADING &quot;SEGMENT|NAME&quot;<br>COLUMN segment_type      FORMAT A7          HEADING &quot;SEGMENT|TYPE&quot;<br>
<hr>
<A name=37></a>COLUMN extents           FORMAT 999         HEADING &quot;EXTENTS&quot;<br>COLUMN kbytes            FORMAT 999,999,999 HEADING &quot;KILOBYTES&quot;<br>COLUMN blocks            FORMAT 9,999,999   HEADING &quot;ALLOC.|&amp;&amp;bs|BLOCKS&quot;<br>COLUMN act_blocks        FORMAT 9,999,990   HEADING &quot;USED|&amp;&amp;bs|BLOCKS&quot;<br>COLUMN pct_block         FORMAT 999.99      HEADING &quot;PCT|BLOCKS|USED&quot;<br>START title132 &quot;Actual Size Report for &amp;owner&quot;<br>SET PAGES 55<br>BREAK ON REPORT ON segment_type SKIP 1<br>COMPUTE SUM OF kbytes ON segment_type REPORT<br>SPOOL rep_out\&amp;db\&amp;owner<br>SELECT<br>     segment_name,<br>     segment_type,<br>     SUM(extents) extents,<br>     SUM(bytes)/1024 kbytes,<br>     SUM(a.blocks) blocks,<br>     NVL(MAX(b.blocks),0) act_blocks,<br>    (MAX(b.blocks)/SUM(a.blocks))*100 pct_block<br> FROM<br>     sys.dba_segments a,<br>     temp_size_table b<br> WHERE<br>     segment_name = UPPER( b.table_name )<br> GROUP BY<br>     segment_name,<br>     segment_type<br> ORDER BY<br>     segment_type,<br>     segment_name;<br>SPOOL OFF<br>TRUNCATE TABLE temp_size_table;<br>SET TERMOUT ON FEEDBACK 15 VERIFY ON PAGESIZE 20 LINESIZE 80 SPACE 1<br>UNDEF qt<br>UNDEF cr<br>TTITLE OFF<br>CLEAR COLUMNS<br>CLEAR COMPUTES<br>PAUSE press enter to continue<br>
<i>Quellcode 10.3: Berichtsskript für die tatsächliche Größe</i><br>
<hr>
<A name=38></a>rem<br>rem Create temp_size_table for use by actsize.sql<br>rem<br>CREATE TABLE temp_size_table (<br>     table_name VARCHAR2(64),<br>     blocks NUMBER);<br>
<i>Quellcode 10.4: Skript zum Erstellen der Tabelle </i>TEMP_SIZE_TABLE<br>
<hr>
<A name=39></a>rem<br>rem  NAME: tab_stat.sql<br>rem<br>rem  FUNCTION: Show table statistics for user's tables or all tables.<br>rem  10/08/01 Updated for 9i Mike Ault<br>rem<br>SET PAGES 56 LINES 132 NEWPAGE 0 VERIFY OFF ECHO OFF FEEDBACK OFF<br>rem<br>COLUMN owner            FORMAT a12            HEADING &quot;Table Owner&quot;<br>COLUMN table_name       FORMAT a20            HEADING &quot;Table&quot;<br>COLUMN tablespace_name  FORMAT a20            HEADING &quot;Tablespace&quot;<br>COLUMN num_rows         FORMAT 999,999,999    HEADING &quot;Rows&quot;<br>COLUMN blocks           FORMAT 999,999        HEADING &quot;Blocks&quot;<br>COLUMN empty_blocks     FORMAT 999,999        HEADING &quot;Empties&quot;<br>COLUMN space_full       FORMAT 999.99         HEADING "% Full&quot;<br>COLUMN chain_cnt        FORMAT 999,999        HEADING &quot;Chains&quot;<br>COLUMN avg_row_len      FORMAT 99,999,999     HEADING &quot;Avg Length|(Bytes)&quot;<br>rem<br>START title132 &quot;Table Statistics Report&quot;<br>DEFINE OUTPUT = 'rep_out\&amp;db\tab_stat..lis'<br>SPOOL &amp;output<br>rem<br>BREAK ON OWNER SKIP 2 ON TABLESPACE_NAME SKIP 1;<br>SELECT owner, table_name, tablespace_name, num_rows, blocks,<br>     empty_blocks,<br>     100*((num_rows *<br>     avg_row_len)/((GREATEST(blocks,1)+empty_blocks)*value))<br>     space_full,<br>     chain_cnt, avg_row_len<br> FROM dba_tables, v$parameter<br> WHERE OWNER NOT IN ('SYS','SYSTEM')<br>     AND num_rows&gt;0<br>     AND name='db_block_size'<br> ORDER BY owner, tablespace_name;<br>SPOOL OFF<br>PAUSE Press enter to continue<br>SET PAGES 22 LINES 80 NEWPAGE 1 VERIFY ON FEEDBACK ON<br>CLEAR COLUMNS<br>CLEAR BREAKS<br>TTITLE OFF<br>
<i>Quellcode 10.5: Berichtsskript für zusätzliche Tabellenangaben</i><br>
<hr>
<A name=40></a>REM<br>REM  Name     : tab_rep.sql<br>REM  FUNCTION : Document table extended parameters<br>REM  Use      : From SQLPLUS<br>REM  MRA  6/13/97 Created for ORACLE8<br>REM  MRA  5/08/99 Updated for ORACLE8i<br>REM  MRA 10/08/01 Updated for Oracle9i<br>REM<br>COLUMN owner            FORMAT a10 HEADING 'Owner'<br>COLUMN table_name       FORMAT a15 HEADING 'Table'<br>COLUMN tablespace_name  FORMAT a13 HEADING 'Tablespace'<br>COLUMN table_type_owner FORMAT a10 HEADING 'Type|Owner'<br>COLUMN table_type       FORMAT a13 HEADING 'Type'<br>COLUMN iot_name         FORMAT a10 HEADING 'IOT|Overflow'<br>COLUMN iot_type         FORMAT a12 HEADING 'IOT or|Overflow'<br>COLUMN nested           FORMAT a6  HEADING 'Nested'<br>COLUMN extern           FORMAT a3  HEADING 'Ext'<br>UNDEF owner<br>SET LINES 130 VERIFY OFF FEEDBACK OFF PAGES 58<br>START title132 'Extended Table Report'<br>SPOOL rep_out\&amp;&amp;db\ext_tab.lis<br>SELECT<br>     owner,<br>     table_name,<br>     tablespace_name,<br>     iot_name,<br>     logging,<br>     partitioned,<br>     iot_type,<br>     'N/A' table_type_owner,<br>     'N/A' table_type,<br>     DECODE(temporary,'N','No',temporary),<br>     nested,<br>     'N/A' extern<br> FROM<br>     dba_tables<br> WHERE<br>     owner LIKE UPPER('%&amp;&amp;owner%')<br>UNION<br>SELECT<br>     owner,<br>     table_name,<br>     tablespace_name,<br>     iot_name,<br>     logging,<br>     partitioned,<br>     iot_type,<br>     table_type_owner,<br>     table_type,<br>     DECODE(temporary,'N','No',temporary),<br>     nested,<br>     'N/A' extern<br> FROM<br>     dba_object_tables<br> WHERE<br>     owner LIKE UPPER('%&amp;&amp;owner%')<br>UNION<br>SELECT<br>     Owner,<br>     'None' tablespace_name,<br>     'N/A' Iot_name,<br>     'N/A' logging,<br>     'N/A' partitioned,<br>     'N/A' Iot_type,<br>     type_owner table_type_owner,<br>
<hr>
<A name=41></a>     type_name table_type,<br>     'N/A' temporary,<br>     'N/A' nested,<br>     'Yes' extern<br> FROM<br>     dba_external_tables<br> WHERE<br>     Owner LIKE UPPER('%&amp;&amp;owner%');<br>SPOOL OFF<br>SET VERIFY ON LINES 80 PAGES 22 FEEDBACK ON<br>TTITLE OFF<br>UNDEF OWNER<br>CLEAR COLUMNS<br>
<i>Quellcode 10.6: Skript zur Dokumentation der erweiterten Tabellenparameter</i><br>
<hr>
<A name=42></a>rem<br>rem  NAME     : tab_stat.sql<br>rem<br>rem  FUNCTION :Show table statistics for a user's tables or all tables.<br>Rem<br> set pages 56 lines 130 newpage 0 verify off echo off feedback off<br>rem<br>COLUMN owner               FORMAT a12          HEADING &quot;Table Owner&quot;<br>COLUMN table_name          FORMAT a17          HEADING &quot;Table&quot;<br>COLUMN tablespace_name     FORMAT a13          HEADING &quot;Tablespace&quot;<br>COLUMN num_rows            FORMAT 99,999,999   HEADING &quot;Rows&quot;<br>COLUMN blocks              FORMAT 99,999       HEADING &quot;Blocks&quot;<br>COLUMN empty_blocks        FORMAT 99,999       HEADING &quot;Empties&quot;<br>COLUMN space_full          FORMAT 999.99       HEADING &quot;% Full&quot;<br>COLUMN chain_cnt           FORMAT 99,999       HEADING &quot;Chains&quot;<br>COLUMN avg_row_len         FORMAT 9,999,999    HEADING &quot;Avg|Length|(Bytes)&quot;<br>COLUMN num_freelist_blocks FORMAT 99,999       HEADING &quot;Num|Freelist|Blocks&quot;<br>COLUMN avg_space_freelist_blocks FORMAT 99,999 HEADING &quot;Avg|Space|Freelist <br>Blocks&quot;<br>rem<br>START title132 &quot;Table Statistics Report&quot;<br>DEFINE OUTPUT = 'rep_out\&amp;db\tab_stat..lis'<br>SPOOL &amp;output<br>rem<br>BREAK ON OWNER SKIP 2 ON TABLESPACE_NAME SKIP 1;<br>SELECT<br>     owner, table_name, tablespace_name,<br>     num_rows, blocks,empty_blocks,<br>     100*((num_rows * avg_row_len)/((GREATEST(blocks,1) + empty_blocks)<br>     * 2048)) space_full,<br>     chain_cnt, avg_row_len,avg_space_freelist_blocks,<br>     num_freelist_blocks<br> FROM<br>     dba_tables<br> WHERE<br>     owner NOT IN ('SYS','SYSTEM')<br>UNION<br>SELECT<br>     owner, table_name, tablespace_name,<br>     num_rows, blocks,empty_blocks,<br>     100*((num_rows * avg_row_len)/((GREATEST(blocks,1) + empty_blocks)<br>     * 2048)) space_full,<br>     chain_cnt, avg_row_len,avg_space_freelist_blocks,<br>     num_freelist_blocks<br> FROM<br>     dba_object_tables<br> WHERE<br>     owner NOT IN ('SYS','SYSTEM')<br> ORDER BY<br>     owner, tablespace_name;<br>SPOOL OFF<br>PAUSE Press enter to continue<br>SET PAGES 22 LINES 80 NEWPAGE 1 VERIFY ON FEEDBACK ON<br>CLEAR COLUMNS<br>CLEAR BREAKS<br>TTITLE OFF<br>
<i>Quellcode 10.7: Berichtsskript für statistische Werte zu Tabellen</i><br>
<hr>
<A name=43></a>rem<br>rem tab_col.sql<br>rem<br>rem FUNCTION: Report on Table and View Column Definitions<br>rem<br>rem MRA 9/18/96<br>rem MRA 6/14/97 Added table level selectivity<br>rem<br>COLUMN owner             FORMAT a10      HEADING Owner<br>COLUMN table_name        FORMAT a30      HEADING &quot;Table or View Name&quot;<br>COLUMN COLUMN_name       FORMAT a32      HEADING &quot;Table or View|Attribute&quot;<br>COLUMN data_type         FORMAT a15      HEADING &quot;Data|Type&quot;<br>COLUMN data_type_owner   FORMAT a13      HEADING &quot;Type|Owner&quot;<br>COLUMN data_length                       HEADING Length<br>COLUMN nullable          FORMAT a5       HEADING Null<br>BREAK ON owner ON table_name SKIP 1<br>SET LINES 132 PAGES 48 FEEDBACK OFF VERIFY OFF<br>START title132 &quot;Table Columns Report&quot;<br>SPOOL rep_out/&amp;db/tab_col<br>SELECT<br>     a.owner,<br>     table_name||' '||object_type table_name,<br>     column_name,<br>     data_type,<br>     data_type_owner,<br>     data_length,<br>     DECODE(nullable,'N','NO','YES') nullable<br> FROM<br>     dba_tab_columns a, dba_objects b<br> WHERE<br>     a.owner=UPPER('&amp;owner') AND<br>     a.owner=b.owner AND<br>     a.table_name LIKE UPPER('%&amp;table%') AND<br>     a.table_name=b.object_name AND<br>     object_type IN ('TABLE','VIEW','CLUSTER')<br> ORDER BY<br>     owner,<br>     object_type,<br>     table_name,<br>     column_id<br>/<br>SPOOL OFF<br>TTITLE OFF<br>SET LINES 80 PAGES 22 FEEDBACK ON VERIFY ON<br>
<i>Quellcode 10.8: Skript zur Ausgabe der Tabellenspalten nach Besitzer und Tabelle</i><br>
<hr>
<A name=44></a>rem<br>rem tab_col_stat.sql<br>rem<br>rem FUNCTION: Report on Table and View Column Definitions<br>rem<br>rem MRA 9/18/96<br>rem MRA 6/14/97 Added table level selectivity<br>rem MRA 5/8/99 Converted to do stats<br>rem<br>COLUMN owner            FORMAT a12      HEADING Owner<br>COLUMN table_name       FORMAT a20      HEADING &quot;Table Name&quot;<br>COLUMN COLUMN_name      FORMAT a13      HEADING &quot;Table|Attribute&quot;<br>COLUMN data_type        FORMAT a10      HEADING &quot;Data|Type&quot;<br>COLUMN avg_col_len      FORMAT 99,999   HEADING &quot;Aver|Length&quot;<br>COLUMN density          FORMAT 9.9999   HEADING &quot;Density&quot;<br>COLUMN last_analyzed                    HEADING &quot;Analyzed&quot;<br>COLUMN num_distinct                     HEADING &quot;Distinct|Values&quot;<br>COLUMN num_nulls                        HEADING &quot;Num.|Nulls&quot;<br>COLUMN sample_size                      HEADING &quot;Sample|Size&quot;<br>BREAK ON owner ON table_name SKIP 1<br>SET LINES 132 PAGES 48 FEEDBACK OFF VERIFY OFF<br>START title132 &quot;Table Column Stats Report&quot;<br>SPOOL rep_out/&amp;db/tab_col<br>SELECT<br>     owner,table_name,column_name,data_type,<br>     num_distinct,density,num_nulls,<br>     TO_CHAR(last_analyzed,'dd-mon-yyyy hh24:mi') last_analyzed,<br>     sample_size, avg_col_len<br> FROM<br>     dba_tab_columns<br> WHERE<br>     owner LIKE UPPER('%&amp;owner%')<br>     and table_name LIKE UPPER('%&amp;tabname%')<br>/<br>SPOOL OFF<br>TTITLE OFF<br>SET LINES 80 PAGES 22 FEEDBACK ON VERIFY ON<br>
<i>Quellcode 10.9: Berichtsskript für statistische Werte zu den Tabellenspalten</i><br>
<hr>
<A name=45></a>rem  ****************************************************************<br>rem<br>rem  NAME     : CHAINING.sql<br>rem<br>rem  FUNCTION : Report number of CHAINED rows within a named table<br>rem<br>rem  NOTES    : Requires DBA privileges.<br>rem             Target table must have column that is the leading<br>rem             portion of an index and is defined as not null.<br>rem             Uses the V$SESSTAT table. USERNAME is the current<br>rem             user.<br>rem             A problem if &gt; 1 session active with that USERID.<br>rem             V$SESSTAT may change between releases and<br>rem             platforms. Make sure that 'table fetch continued row'<br>rem             is a valid statistic.<br>rem             This routine can be run by AUTO_CHN.sql by remarking<br>rem             the two accepts and un-remarking the two defines.<br>Rem<br>rem  INPUTS   : obj_own = the owner of the table.<br>rem             obj_nam = the name of the table.<br>Rem<br>rem  ****************************************************************<br>ACCEPT obj_own PROMPT 'Enter the table owner''s name: '<br>ACCEPT obj_nam PROMPT 'Enter the name of the table: '<br>
rem DEFINE obj_own = &amp;1  fl Remove comment to use with auto_chain<br>rem DEFINE obj_nam = &amp;2  fl Remove comment to use with auto_chain<br>
SET TERMOUT OFF FEEDBACK OFF VERIFY OFF ECHO OFF HEADING OFF<br>SET EMBEDDED ON<br>COLUMN statistic# NEW_VALUE stat_no NOPRINT<br>SELECT<br>     statistic#<br> FROM<br>     v$statname<br> WHERE<br>     n.name = 'table fetch continued row'<br>/<br>
rem Find out who we are in terms of sid<br>COLUMN sid NEW_VALUE user_sid<br>SELECT<br>     distinct sid<br> FROM<br>     v$session<br> WHERE<br>     audsid = USERENV('SESSIONID')<br>/<br>
rem Find the last col of the table and a not null indexed column<br>COLUMN column_name     NEW_VALUE last_col<br>COLUMN name            NEW_VALUE indexed_column<br>COLUMN value           NEW_VALUE before_count<br>SELECT<br>     column_name<br> FROM<br>     dba_tab_columns<br> WHERE<br>     table_name = upper('&amp;&amp;obj_nam')<br>     and owner = upper('&amp;&amp;obj_own')<br> ORDER BY<br>     column_id<br>/<br>SELECT<br>     c.name<br>
<hr>
<A name=46></a> FROM<br>     sys.col$ c,<br>     sys.obj$ idx,<br>     sys.obj$ base,<br>     sys.icol$ ic<br> WHERE<br>     base.obj#     = c.obj#<br>        and ic.bo# = base.obj#<br>        and ic.col# = c.col#<br>        and base.owner# = (SELECT user# FROM sys.user$<br>                            WHERE name = UPPER('&amp;&amp;obj_own'))<br>        and ic.obj# = idx.obj#<br>        and base.name = UPPER('&amp;&amp;obj_nam')<br>        and ic.pos# = 1<br>        and c.null$ &gt; 0<br>/<br>SELECT value<br>  FROM v$sesstat<br> WHERE v$sesstat.sid = &amp;user_sid<br>   AND v$sesstat.statistic# = &amp;stat_no<br>/<br>rem Select every row from the target table<br>SELECT &amp;last_col xx<br>  FROM &amp;obj_own..&amp;obj_nam<br> WHERE &amp;indexed_column &lt;= (SELECT MAX(&amp;indexed_column)<br>                             FROM &amp;obj_own..&amp;obj_nam)<br>/<br>COLUMN value NEW_VALUE after_count<br>SELECT value<br>  FROM v$sesstat<br> WHERE v$sesstat.sid = &amp;user_sid<br>   AND v$sesstat.statistic# = &amp;stat_no<br>/<br>SET TERMOUT ON<br>
SELECT<br>     'Table '||UPPER('&amp;obj_own')||'.'||UPPER('&amp;obj_nam')||' contains '||<br>     (TO_NUMBER(&amp;after_count) - TO_NUMBER(&amp;before_count))||<br>     ' chained row'||<br>     DECODE(to_NUMBER(&amp;after_count) - TO_NUMBER(&amp;before_count),1,'.','s.')<br>  FROM dual<br> WHERE RTRIM('&amp;indexed_column') IS NOT NULL<br>/<br>
rem If we don't have an indexed column this won't work so say so<br>SELECT 'Table '||<br>     UPPER('&amp;obj_own')||'.'||UPPER('&amp;obj_nam')||<br>     ' has no indexed, not null columns.'<br>  FROM dual<br> WHERE RTRIM('&amp;indexed_column') IS NULL<br>/<br>
SET TERMOUT ON FEEDBACK 15 VERIFY ON PAGESIZE 20 LINESIZE 80 SPACE 1<br>SET HEADING ON<br>UNDEF obj_nam<br>UNDEF obj_own<br>UNDEF before_count<br>UNDEF after_count<br>UNDEF indexed_column<br>UNDEF last_col<br>UNDEF stat_no<br>UNDEF user_sid<br>CLEAR COLUMNS<br>CLEAR COMPUTES<br>
<i>Quellcode 10.10: Interaktives SQL-Skript zur Ermittlung verketteter Zeilen in einer Tabelle</i><br>
rem  **********************************************************<br>
<hr>
<A name=47></a>rem<br>rem  NAME     : AUTO_CHN.sql<br>rem<br>rem  FUNCTION : Run CHAINING.sql for all of a users tables.<br>Rem<br>rem  NOTES    : Requires mod to CHAINING.sql. See CHAINING.sql header<br>rem<br>rem  INPUTS   :<br>rem             tabown = Name of owner.<br>Rem<br>rem ***********************************************************<br>rem<br>ACCEPT tabown PROMPT 'Enter table owner: '<br>rem<br>SET TERMOUT OFF FEEDBACK OFF VERIFY OFF ECHO OFF HEADING OFF PAGES 999<br>SET EMBEDDED ON<br>COLUMN name NEW_VALUE db NOPRINT<br>SELECT name FROM v$database;<br>SPOOL rep_out\auto_chn.gql<br>rem<br>SELECT 'start chaining &amp;tabown '||table_name<br>  FROM dba_tables<br> WHERE owner = UPPER('&amp;tabown')<br>/<br>
SPOOL OFF<br>SPOOL rep_out\&amp;db\chaining<br>START rep_out\auto_chn.gql<br>SPOOL OFF<br>UNDEF tabown<br>SET TERMOUT ON FEEDBACK 15 VERIFY ON PAGESIZE 20 LINESIZE 80 SPACE 1<br>SET EMBEDDED OFF<br>HO del rep_out\auto_chn.gql<br>PAUSE Press enter to continue<br>
<i>Quellcode 10.11: Das Skript </i>auto_chn.sql<i> zur Automatisierung der Verkettungsanalyse</i><br>
<hr>
<A name=48></a>rem  *******************************************************************<br>rem  NAME     : db_tgnts.sql<br>rem<br>rem  FUNCTION : Produce report of table or procedure grants showing<br>rem             GRANTOR, GRANTEE or ROLE and specific GRANTS.<br>Rem<br>rem  INPUTS   : Owner name<br>rem  *******************************************************************<br>rem<br>COLUMN grantee         FORMAT A18   HEADING &quot;Grantee|or Role&quot;<br>COLUMN owner           FORMAT A18   HEADING &quot;Owner&quot;<br>COLUMN table_name      FORMAT A30   HEADING &quot;Table|or Proc&quot;<br>COLUMN grantor         FORMAT A18   HEADING &quot;Grantor&quot;<br>COLUMN privilege       FORMAT A10   HEADING &quot;Privilege&quot;<br>COLUMN grantable       FORMAT A19   HEADING &quot;Grant|Option?&quot;<br>rem<br>BREAK ON owner SKIP 4 ON table_name SKIP 1 ON grantee ON grantor ON REPORT<br>rem<br>SET LINESIZE 130 PAGES 56 VERIFY OFF FEEDBACK OFF<br>START title132 &quot;TABLE GRANTS BY OWNER AND TABLE&quot;<br>DEFINE OUTPUT = rep_out/&amp;&amp;db/db_tgnts<br>SPOOL &amp;output<br>REM<br>SELECT<br>     owner,<br>     table_name,<br>     grantee,<br>     grantor,<br>     privilege,<br>     grantable<br> FROM<br>     dba_tab_privs<br> WHERE<br>     owner NOT IN ('SYS','SYSTEM')<br> ORDER BY<br>     owner,<br>     table_name,<br>     grantor,<br>     grantee;<br>REM<br>SPOOL OFF<br>PAUSE Press enter to continue<br>
<i>Quellcode 10.12: SQL-Skript zur Anzeige der Zugriffsberechtigungen auf Objektebene</i><br>
<hr>
<A name=49></a>rem<br>rem  Name     : tab_part.sql<br>rem  Function : Report on partitioned table structure<br>rem  History  : MRA 6/13/97 Created<br>rem<br>COLUMN table_owner        FORMAT a10   HEADING 'Owner'<br>COLUMN table_name         FORMAT a15   HEADING 'Table'<br>COLUMN partition_name     FORMAT a15   HEADING 'Partition'<br>COLUMN tablespace_name    FORMAT a15   HEADING 'Tablespace'<br>COLUMN high_value         FORMAT a10   HEADING 'Partition|Value'<br>COLUMN subpartition_count FORMAT 9,999 HEADING 'Sub-Partitions'<br>SET LINES 130<br>START title132 'Table Partition Files'<br>BREAK ON table_owner ON table_name<br>SPOOL rep_out/&amp;&amp;db/tab_part.lis<br>SELECT<br>     table_owner,<br>     table_name,<br>     partition_name,<br>     sub_partition_count,<br>     high_value,<br>     tablespace_name,<br>     logging<br> FROM sys.dba_tab_partitions<br> ORDER BY table_owner,table_name<br>/<br>SPOOL OFF<br>
<i>Quellcode 10.13: Berichtsskript für die Strukturen partitionierter Tabellen</i><br>
<hr>
<A name=50></a>rem<br>rem  NAME     : Tab_pstor.sql<br>rem  FUNCTION : Provide data on part. table stor. charcacteristics<br>rem  HISTORY  : MRA 6/13/97 Created<br>rem<br>COLUMN table_owner        FORMAT a6      HEADING 'Owner'<br>COLUMN table_name         FORMAT a14     HEADING 'Table'<br>COLUMN partition_name     FORMAT a9      HEADING 'Partition'<br>COLUMN tablespace_name    FORMAT a11     HEADING 'Tablespace'<br>COLUMN pct_free           FORMAT 9999    HEADING '%|Free'<br>COLUMN pct_used           FORMAT 999     HEADING '%|Use'<br>COLUMN ini_trans          FORMAT 9999    HEADING 'Init|Tran'<br>COLUMN max_trans          FORMAT 9999    HEADING 'Max|Tran'<br>COLUMN initial_extent     FORMAT 9999999 HEADING 'Init|Extent'<br>COLUMN next_extent        FORMAT 9999999 HEADING 'Next|Extent'<br>COLUMN max_extent                        HEADING 'Max|Extents'<br>COLUMN pct_increase       FORMAT 999     HEADING '%|Inc'<br>COLUMN partition_position FORMAT 9999    HEADING 'Part|Nmbr'<br>SET LINES 130<br>START title132 'Table Partition File Storage'<br>BREAK ON table_owner on table_name<br>SPOOL rep_out/&amp;&amp;db/tab_pstor.lis<br>SELECT<br>     table_owner,<br>     table_name,<br>     tablespace_name,<br>     partition_name,<br>     partition_position,<br>     pct_free,<br>     pct_used,<br>     ini_trans,<br>     max_trans,<br>     initial_extent,<br>     next_extent,<br>     max_extent,<br>     pct_increase<br> FROM sys.dba_tab_partitions<br> ORDER BY table_owner,table_name<br>/<br>SPOOL OFF<br>
<i>Quellcode 10.14: Berichtsskript für die Speichereigenschaften einer Partition</i><br>
<hr>
<A name=51></a>rem<br>rem  Name     : tab_part_stat.sql<br>rem  Function : Report on partitioned table statistics<br>rem  History  : MRA 6/13/97 Created<br>rem<br>COLUMN table_name      FORMAT a15  HEADING 'Table'<br>COLUMN partition_name  FORMAT a15  HEADING 'Partition'<br>COLUMN num_rows                    HEADING 'Num|Rows'<br>COLUMN blocks                      HEADING 'Blocks'<br>COLUMN avg_space                   HEADING 'Avg|Space'<br>COLUMN chain_cnt                   HEADING 'Chain|Count'<br>COLUMN avg_row_len                 HEADING 'Avg|Row|Length'<br>COLUMN last_analyzed               HEADING 'Analyzed'<br>ACCEPT owner1 PROMPT 'Which Owner to report on?:'<br>SET LINES 130<br>START title132 'Table Partition Statistics For &amp;owner1'<br>BREAK ON table_owner ON table_name ON partition_name<br>SPOOL rep_out/&amp;&amp;db/tab_part_stat.lis<br>SELECT<br>     table_name,<br>     partition_name,<br>     num_rows,<br>     blocks,<br>     avg_space,<br>     chain_cnt,<br>     avg_row_len,<br>     to_char(last_analyzed,'dd-mon-yyyy hh24:mi') last_analyzed<br> FROM<br>     sys.dba_tab_partitions<br> WHERE<br>     table_owner LIKE UPPER('%&amp;&amp;owner1%')<br> ORDER BY<br>     table_owner,table_name<br>/<br>SPOOL OFF<br>CLEAR BREAKS<br>CLEAR COLUMNS<br>TTITLE OFF<br>UNDEF owner1<br>
<i>Quellcode 10.15: Berichtsskript für statistische Werte zu Partitionen</i><br>
<hr>
<A name=52></a>rem<br>rem  Name     : tab_subpart.sql<br>rem  Function : Report on partitioned table structure<br>rem  History  : MRA 6/13/97 Created<br>rem<br>COLUMN table_owner NEW_VALUE owner1 NOPRINT<br>COLUMN table_name      FORMAT a15   HEADING 'Table'<br>COLUMN partition_name  FORMAT a15   HEADING 'Partition'<br>COLUMN tablespace_name FORMAT a15   HEADING 'Tablespace'<br>COLUMN initial_extent  FORMAT 9,999 HEADING 'Initial|Extent (K)'<br>COLUMN next_extent     FORMAT 9,999 HEADING 'Next|Extent (K)'<br>COLUMN pct_increase    FORMAT 999   HEADING 'PCT|Increase'<br>SET LINES 130<br>START title132 'Table Sub-Partition Files For &amp;owner1'<br>BREAK ON table_owner ON table_name ON partition_name<br>SPOOL rep_out/&amp;&amp;db/tab_subpart.lis<br>SELECT<br>     table_owner,<br>     table_name,<br>     partition_name,<br>     subpartition_name,<br>     tablespace_name,<br>     logging,<br>     initial_extent/1024 initial_extent,<br>     next_extent/1024 next_extent,<br>     pct_increase<br>FROM sys.dba_tab_subpartitions<br>ORDER BY table_owner,table_name,partition_name<br>/<br>SPOOL OFF<br>
<i>Quellcode 10.16: Berichtsskript für Teilpartitionen</i><br>
<hr>
<A name=53></a>rem<br>rem  Name     : tab_subpart_stat.sql<br>rem  Function : Report on partitioned table structure<br>rem  History  : MRA 6/13/97 Created<br>rem<br>COLUMN table_name         FORMAT a15  HEADING 'Table'<br>COLUMN partition_name     FORMAT a15  HEADING 'Partition'<br>COLUMN subpartition_name  FORMAT a15  HEADING 'Sub|Partition'<br>COLUMN num_rows                       HEADING 'Num|Rows'<br>COLUMN blocks                         HEADING 'Blocks'<br>COLUMN avg_space                      HEADING 'Avg|Space'<br>COLUMN chain_cnt                      HEADING 'Chain|Count'<br>COLUMN avg_row_len                    HEADING 'Avg|Row|Length'<br>COLUMN last_analyzed                  HEADING 'Analyzed'<br>ACCEPT owner1 PROMPT 'Owner to Report On?: '<br>SET LINES 130<br>START title132 'Table Sub-Partition Statistics For &amp;owner1'<br>BREAK ON table_owner ON table_name ON partition_name<br>SPOOL rep_out/&amp;&amp;db/tab_subpart_stat.lis<br>SELECT<br>     table_owner,<br>     table_name,<br>     partition_name,<br>     subpartition_name,<br>     num_rows,<br>     blocks,<br>     avg_space,<br>     chain_cnt,<br>     avg_row_len,<br>     to_char(last_analyzed,'dd-mon-yyyy hh24:mi') last_analyzed<br> FROM<br>     sys.dba_tab_subpartitions<br> WHERE<br>     Table_owner LIKE UPPER('%&amp;&amp;owner1%')<br> ORDER BY<br>     table_owner,table_name,partition_name<br>/<br>SPOOL OFF<br>CLEAR COLUMNS<br>TTITLE OFF<br>UNDEF owner1<br>
<i>Quellcode 10.17: Berichtsskript für statistische Werte zu Teilpartitionen</i><br>
<hr>
<A name=54></a>rem<br>rem  NAME    : tab_nest.sql<br>rem  PURPOSE : Report on Nested Tables<br>rem  HISTORY : MRA 6/14/97 Created<br>rem                5/08/99 Updated to Oracle8i<br>rem<br>COLUMN owner               FORMAT a10 HEADING 'Owner'<br>COLUMN table_name          FORMAT a15 HEADING 'Store Table'<br>COLUMN table_type_owner    FORMAT a10 HEADING 'Type|Owner'<br>COLUMN table_type_name     FORMAT a15 HEADING 'Type|Name'<br>COLUMN parent_table_name   FORMAT a25 HEADING 'Parent|Table'<br>COLUMN parent_table_column FORMAT a12 HEADING 'Parent|Column'<br>COLUMN storage_spec        FORMAT a15 HEADING 'Storage|Spec'<br>COLUMN return_type         FORMAT a7  HEADING 'Return|Type'<br>SET PAGES 58 LINES 132 VERIFY OFF FEEDBACK OFF<br>START title132 'Nested Tables'<br>BREAK ON owner<br>SPOOL rep_out\&amp;db\tab_nest.lis<br>SELECT<br>     owner,<br>     table_name,<br>     table_type_owner,<br>     table_type_name,<br>     parent_table_name,<br>     parent_table_column,<br>     LTRIM(storage_spec) storage_spec,<br>     LTRIM(return_type) return_type<br> FROM<br>     sys.dba_nested_tables<br> ORDER BY<br>     owner;<br>SPOOL OFF<br>
<i>Quellcode 10.18: Berichtsskript zur Überwachung von verschachtelten Tabellen</i><br>
<hr>
<A name=55></a>REM  EXT_TAB.SQL<br>REM  MRA 10/08/01 Initial Creation<br>REM  Script to monitor external tables<br>REM<br>COLUMN owner                   FORMAT a8   HEADING 'Owner'<br>COLUMN table_name              FORMAT a15  HEADING 'Table'<br>COLUMN type_owner              FORMAT a8   HEADING 'Type|Owner'<br>COLUMN type_name               FORMAT a13  HEADING 'Type|Name'<br>COLUMN default_directory_owner FORMAT a10  HEADING 'Dir|Owner'<br>COLUMN default_directory_name  FORMAT a10  HEADING 'Dir|Name'<br>COLUMN reject_limit            FORMAT a9   HEADING 'Reject|Limit'<br>COLUMN access_type             FORMAT a6   HEADING 'Access|Type'<br>COLUMN access_parameters FORMAT a35 WORD_WRAPPED HEADING 'Access Parameters'<br>SET LINES 132 PAGES 55<br>START title132 'External Tables'<br>SPOOL rep_out/&amp;db/ext_tab<br>SELECT<br>     owner,<br>     table_name,<br>     type_owner,<br>     type_name,<br>     default_directory_owner,<br>     default_directory_name,<br>     reject_limit,<br>     access_type,<br>     access_parameters<br> FROM dba_external_tables<br>/<br>SPOOL OFF<br>SET lines 80 Pages 22<br>
<i>Quellcode 10.19: Berichtsskript zur Überwachung externer Tabellen</i><br>
rem<br>rem  NAME     : ind_rep.sql<br>rem  FUNCTION : Report on indexes<br>rem  HISTORY  : MRA 6/14/97 Creation<br>rem<br>COLUMN owner           FORMAT a8   HEADING 'Index|Owner'<br>COLUMN index_name      FORMAT a27  HEADING 'Index'<br>COLUMN index_type      FORMAT a6   HEADING 'Type|Index'<br>COLUMN table_owner     FORMAT a8   HEADING 'Table|Owner'<br>COLUMN table_name      FORMAT a24  HEADING 'Table Name'<br>COLUMN table_type      FORMAT a10  HEADING 'Table|Type'<br>COLUMN uniqueness      FORMAT a1   HEADING 'U|n|i|q|u|e'<br>COLUMN tablespace_name FORMAT a13  HEADING 'Tablespace'<br>COLUMN column_name     FORMAT a25  HEADING 'Col. Name'<br>SET PAGES 58 LINES 130 FEEDBACK OFF VERIFY OFF<br>BREAK ON owner<br>START title132 'Expandeded Index Report'<br>SPOOL rep_out\&amp;db\ind_exp.lis<br>SELECT<br>     a.owner,<br>     a.index_name,<br>     a.index_type,<br>     a.table_owner,<br>     a.table_name,<br>     a.table_type,<br>     DECODE<br>       (a.uniqueness, 'UNIQUE', 'U','NONUNIQUE','N') uniqueness,<br>     a.tablespace_name,<br>     b.column_name<br> FROM<br>     dba_indexes a, dba_ind_columns b<br> WHERE<br>     owner LIKE UPPER('%&amp;owner%')<br>
<hr>
<A name=56></a>     AND a.owner=b.index_owner(+)<br>     AND a.index_name=b.index_name(+)<br> ORDER BY<br>     owner, index_type;<br>SPOOL OFF<br>
<i>Quellcode 10.20: Berichtsskript für statistische Werte zu den Tabellenspalten</i><br>
<hr>
<A name=57></a>rem<br>rem  NAME     : brown.sql<br>rem  FUNCTION : Analyze indexes and produce stat report<br>rem  FUNCTION : Including browning indicator<br>rem<br>rem  HISTORY  : MRA 6/15/97 Created<br>rem<br>COL del_lf_rows_len   FORMAT 999,999,999 HEADING 'Deleted Bytes'<br>COL lf_rows_len       FORMAT 999,999,999 HEADING 'Filled Bytes'<br>COL browning          FORMAT 999.90      HEADING 'Percent|Browned'<br>COL height            FORMAT 999,999     HEADING 'Height'<br>COL blocks            FORMAT 999,999     HEADING 'Blocks'<br>COL distinct_keys     FORMAT 999,999,999 HEADING '#|Keys'<br>COL most_repeated_key FORMAT 999999999   HEADING 'Most|Repeated|Key'<br>COL used_space        FORMAT 999999999   HEADING 'Used|Space'<br>COL rows_per_key      FORMAT 999999      HEADING 'Rows|Per|Key'<br>ACCEPT owner PROMPT 'Enter table owner name: '<br>SET HEADING OFF FEEDBACK OFF VERIFY OFF ECHO OFF RECSEP OFF<br>SET PAGES 0<br>TTITLE OFF<br>DEFINE cr='CHR(10)'<br>SPOOL index_sz.sql<br>SELECT<br>     'CREATE TABLE stat_temp AS SELECT * FROM index_stats;'||&amp;&amp;cr||<br>     'TRUNCATE TABLE stat_temp;'<br> FROM dual;<br>SELECT<br>     'ANALYZE INDEX '||owner||'.'||index_name||<br>     ' VALIDATE STRUCTURE;'||&amp;&amp;cr||<br>     'INSERT INTO stat_temp SELECT * FROM index_stats;'||&amp;&amp;cr||<br>     'COMMIT;'<br> FROM<br>     dba_indexes<br> WHERE<br>     owner=UPPER('&amp;owner');<br>SPOOL OFF<br>PROMPT 'Analyzing Indexes'<br>SET FEEDBACK OFF TERMOUT OFF LINES 132 VERIFY OFF<br>START index_sz.sql<br>SET TERMOUT ON FEEDBACK ON VERIFY ON LINES 132 PAGES 58<br>START title132 &quot;Index Statistics Report&quot;<br>SPOOL rep_out/&amp;db/browning.lst<br>SELECT<br>     name,<br>     del_lf_rows_len,<br>     lf_rows_len,<br>     (del_lf_rows_len/<br>      DECODE((lf_rows_len+del_lf_rows_len),0,1,lf_rows_len+<br>      del_lf_rows_len))*100 browning,<br>     height,<br>     blocks,<br>     distinct_keys,<br>     most_repeated_key,<br>     used_space,<br>     rows_per_key<br> FROM<br>     stat_temp<br> WHERE rows_per_key&gt;0;<br>SPOOL OFF<br>SET FEEDBACK ON TERMOUT ON LINES 80 VERIFY ON<br>HOST del stat_temp<br>
<i>Quellcode 10.21: Skript zur Ermittlung der statistischen Werte zu Indices mithilfe des </i>ANALYZE INDEX<i>-Befehls</i><br>
<hr>
<A name=58></a>rem  NAME     : IN_STAT.sql<br>rem<br>rem  FUNCTION : Report on index statistics<br>rem  INPUTS   : 1 = Index owner     2 = Index name<br>rem<br>DEF iowner = '&amp;OWNER'<br>DEF iname = '&amp;INDEX'<br>SET PAGES 56 LINES 130 VERIFY OFF FEEDBACK OFF<br>COLUMN owner                   FORMAT a8          HEADING &quot;Owner&quot;<br>COLUMN index_name              FORMAT a25         HEADING &quot;Index&quot;<br>COLUMN status                  FORMAT a7          HEADING &quot;Status&quot;<br>COLUMN blevel                  FORMAT 9,999       HEADING &quot;Tree|Level&quot;<br>COLUMN leaf_blocks             FORMAT 999,999,999 HEADING &quot;Leaf Blk&quot;<br>COLUMN distinct_keys           FORMAT 999,999,999 HEADING &quot;# Keys&quot;<br>COLUMN avg_leaf_blocks_per_key FORMAT 9,999       HEADING &quot;Avg.|LB/Key&quot;<br>COLUMN avg_data_blocks_per_key FORMAT 9,999       HEADING &quot;Avg.|DB/Key&quot;<br>COLUMN clustering_factor       FORMAT 999,999     HEADING &quot;Clstr|Factor&quot;<br>COLUMN num_rows                FORMAT 999,999,999 HEADING &quot;Number|Rows&quot;<br>COLUMN sample_size             FORMAT 99,999      HEADING &quot;Sample|Size&quot;<br>COLUMN last_analyzed                              HEADING 'Analysis|Date'<br>rem<br>BREAK ON owner<br>START title132 &quot;Index Statistics Report&quot;<br>SPOOL rep_out\&amp;db\ind_stat<br>rem<br>SELECT<br>     owner, index_name, status, blevel, leaf_blocks,<br>     distinct_keys, avg_leaf_blocks_per_key,<br>     avg_data_blocks_per_key, clustering_factor,<br>     num_rows, sample_size, last_analyzed<br> FROM<br>     dba_indexes<br> WHERE<br>     owner LIKE UPPER('&amp;&amp;iowner')<br>     AND index_name LIKE UPPER('&amp;&amp;iname')<br>     AND num_rows&gt;0<br> ORDER BY<br>     1,2;<br>rem<br>SPOOL OFF<br>SET PAGES 22 LINES 80 VERIFY ON FEEDBACK ON<br>CLEAR COLUMNS<br>UNDEF iowner<br>UNDEF iname<br>UNDEF owner<br>UNDEF name<br>TTITLE OFF<br>
<i>Quellcode 10.22: Bericht für statistische Werte zu Indices unter Oracle8, Oracle8i und Oracle9i</i><br>
<hr>
<A name=59></a>rem<br>rem  Name     : ind_part.sql<br>rem  Function : Report on partitioned index structure<br>rem  History  : MRA 6/14/97 Created<br>rem             MRA 5/10/99 Updated for Subpartitions<br>rem<br>COLUMN index_owner       FORMAT a10  HEADING 'Owner'<br>COLUMN index_name        FORMAT a15  HEADING 'Index'<br>COLUMN partition_name    FORMAT a15  HEADING 'Partition'<br>COLUMN subpartition_name FORMAT a15  HEADING 'Sub|Partition'<br>COLUMN tablespace_name   FORMAT a15  HEADING 'Tablespace'<br>COLUMN high_value        FORMAT a10  HEADING 'Partition|Value'<br>COLUMN status            FORMAT a10  Heading 'Status'<br>SET LINES 130<br>START title132 'Index Partition Files'<br>BREAK ON index_owner ON index_name<br>SPOOL rep_out/&amp;&amp;db/ind_part.lis<br>SELECT<br>     a.index_owner,<br>     a.index_name,<br>     a.partition_name,<br>     a.high_value,<br>     b.subpartition_name,<br>     b.tablespace_name,<br>     b.logging,<br>     b.status<br> FROM sys.dba_ind_partitions a, sys.dba_ind_subpartitions b<br> WHERE a.owner=b.owner<br>     AND a.index_name=b.index_name<br>     And a.partition_name=b.partition_name<br> ORDER BY a.index_owner,a.index_name,a.partition_name,<br>     b.subpartition_position<br>/<br>SPOOL OFF<br>
<i>Quellcode 10.23: Berichtsskript zur Überwachung der Partitionsdateien eines Index</i><br>
<hr>
<A name=60></a>rem<br>rem  NAME     : ind_pstor.sql<br>rem  FUNCTION : Provide data on partitioned index storage charcacteristics<br>rem  HISTORY  : MRA 6/13/97 Created<br>rem<br>COLUMN owner             FORMAT a6      HEADING 'Owner'<br>COLUMN index_name        FORMAT a14     HEADING 'Index'<br>COLUMN partition_name    FORMAT a9      HEADING 'Partition'<br>COLUMN tablespace_name   FORMAT a11     HEADING 'Tablespace'<br>COLUMN pct_free          FORMAT 9999    HEADING '%|Free'<br>COLUMN ini_trans         FORMAT 9999    HEADING 'Init|Tran'<br>COLUMN max_trans         FORMAT 9999    HEADING 'Max|Tran'<br>COLUMN initial_extent    FORMAT 9999999 HEADING 'Init|Extent'<br>COLUMN next_extent       FORMAT 9999999 HEADING 'Next|Extent'<br>COLUMN max_extent                       HEADING 'Max|Extents'<br>COLUMN pct_increase      FORMAT 999     HEADING '%|Inc'<br>COLUMN distinct_keys     FORMAT 9999999 HEADING '#Keys'<br>COLUMN clustering_factor FORMAT 999999  HEADING 'Clus|Fact'<br>SET LINES 130<br>START title132 'Index Partition File Storage'<br>BREAK ON index_owner on index_name<br>SPOOL rep_out/&amp;&amp;db/ind_pstor.lis<br>SELECT<br>     index_owner,<br>     index_name,<br>     tablespace_name,<br>     partition_name,<br>     pct_free,<br>     ini_trans,<br>     max_trans,<br>     initial_extent,<br>     next_extent,<br>     max_extent,<br>     pct_increase,<br>     distinct_keys,<br>     clustering_factor<br> FROM sys.dba_ind_partitions<br> ORDER BY index_owner,index_name<br>/<br>SPOOL OFF<br>
<i>Quellcode 10.24: Berichtsskript für statistische Werte und Speicherangaben von partitionierten Indices</i><br>
<hr>
<A name=61></a>rem<br>rem  NAME     : ind_subpstor.sql<br>rem  FUNCTION : Get data on subpartitioned index charcacteristics<br>rem  HISTORY  : MRA 5/10/99 Created<br>rem<br>COLUMN owner             FORMAT a6      HEADING 'Owner'<br>COLUMN index_name        FORMAT a14     HEADING 'Index'<br>COLUMN partition_name    FORMAT a9      HEADING 'Partition'<br>COLUMN subpartition_name FORMAT a9      HEADING 'Sub|Partition'<br>COLUMN tablespace_name   FORMAT a11     HEADING 'Tablespace'<br>COLUMN pct_free          FORMAT 9999    HEADING '%|Free'<br>COLUMN ini_trans         FORMAT 9999    HEADING 'Init|Tran'<br>COLUMN max_trans         FORMAT 9999    HEADING 'Max|Tran'<br>COLUMN initial_extent    FORMAT 9999999 HEADING 'Init|Extent'<br>COLUMN next_extent       FORMAT 9999999 HEADING 'Next|Extent'<br>COLUMN max_extent                       HEADING 'Max|Extents'<br>COLUMN pct_increase      FORMAT 999     HEADING '%|Inc'<br>COLUMN distinct_keys     FORMAT 9999999 HEADING '#Keys'<br>COLUMN clustering_factor FORMAT 999999  HEADING 'Clus|Fact'<br>COLUMN num_rows          FORMAT 9999999 HEADING 'Number|Rows'<br>SET LINES 130<br>START title132 'Index SubPartition File Storage'<br>BREAK ON index_owner on index_name<br>SPOOL rep_out/&amp;&amp;db/ind_pstor.lis<br>SELECT<br>     index_owner,<br>     index_name,<br>     partition_name,<br>     sub_partition_name,<br>     tablespace_name,<br>     pct_free,<br>     ini_trans,<br>     max_trans,<br>     initial_extent,<br>     next_extent,<br>     max_extent,<br>     pct_increase,<br>     distinct_keys,<br>     clustering_factor,<br>     num_rows<br> FROM sys.dba_ind_subpartitions<br> ORDER BY index_owner,index_name,partition_name,subpartition_position<br>/<br>SPOOL OFF<br>
<i>Quellcode 10.25: Berichtsskript für statistische Werte und Speicherangaben für Teilpartitionen von Indice</i><br>
<hr>
<A name=62></a>rem<br>rem  NAME     : ind_func.sql<br>rem  FUNCTION : Get data on functional index charcacteristics<br>rem  HISTORY  : MRA 5/12/99 Created<br>rem<br>COLUMN owner             FORMAT a6            HEADING 'Owner'<br>COLUMN index_name        FORMAT a14           HEADING 'Index'<br>COLUMN table_name        FORMAT a20           HEADING 'Table'<br>COLUMN column_expression FORMAT a80 WORD_WRAPPED HEADING 'Expression'<br>SET LINES 130<br>START title132 'Functional Index Report'<br>BREAK ON index_owner on index_name<br>SPOOL rep_out/&amp;&amp;db/ind_func.lis<br>SELECT<br>     Index_owner,<br>     index_name,<br>     table_name,<br>     column_expression<br> FROM<br>     Dba_ind_expressions<br> WHERE<br>     Index_owner LIKE '%&amp;&amp;owner%'<br>     And index_name like '%&amp;&amp;index%'<br> ORDER BY<br>     Index_owner,index_name,column_position;<br>SPOOL OFF<br>TTITLE OFF<br>
<i>Quellcode 10.26: Berichtsskript für funktionsbasierte Indices</i><br>
<hr>
<A name=63></a>REM  bmj_Index.sql<br>REM  MRA 10/10/01<br>COLUMN owner       FORMAT a10  HEADING 'Index|Owner'<br>COLUMN index_name  FORMAT a25  HEADING 'Index|Name'<br>COLUMN table_owner FORMAT a10  HEADING 'Table|Owner'<br>COLUMN table_name  FORMAT a15  HEADING 'Table|Name'<br>COLUMN column_name FORMAT a15  HEADING 'Column|Name'<br>SET LINES 132<br>START title132 'Bitmap Join Indexes'<br>SPOOL rep_out/&amp;db/bmj_index<br>SELECT a.owner, a.index_name, b.table_owner, b.table_name, b.column_name<br> FROM dba_indexes a, dba_join_ind_columns b<br> WHERE a.owner = UPPER('&amp;owner')<br>     and a.join_index='YES'<br>     and a.owner=b.index_owner<br>     and a.index_name=b.index_name<br>/<br>SPOOL OFF<br>SET LINES 80<br>TTITLE OFF<br>
<i>Quellcode 10.27: Berichtsskript für Bitmap-Join-Indices</i><br>
<hr>
<A name=64></a>rem<br>rem File    : CLU_REP.SQL<br>rem Purpose : Document Cluster Data<br>rem Use     : From user with access to DBA_ views<br>rem<br>rem When     Who        What<br>rem ----     --------   ------------------------<br>rem 5/27/93  Mike Ault  Initial Creation<br>rem 6/15/97  Mike Ault  Verified against Oracle8<br>rem 10/11/01 Mike Ault  Verified against oracle9i<br>rem<br>COLUMN owner            FORMAT a10<br>COLUMN cluster_name     FORMAT a15 HEADING &quot;Cluster&quot;<br>COLUMN tablespace_name  FORMAT a20 HEADING &quot;Tablespace&quot;<br>COLUMN table_name       FORMAT a20 HEADING &quot;Table&quot;<br>COLUMN tab_column_name  FORMAT a20 HEADING &quot;Table Column&quot;<br>COLUMN clu_column_name  FORMAT a20 HEADING &quot;Cluster Column&quot;<br>SET PAGES 56 LINES 130 FEEDBACK OFF<br>START title132 &quot;Cluster Report&quot;<br>BREAK ON owner SKIP 1 ON cluster ON tablespace<br>SPOOL rep_out\&amp;db\cluster<br>SELECT<br>     a.owner,a.cluster_name,tablespace_name,<br>     table_name,tab_column_name,clu_column_name<br> FROM<br>     dba_clusters a,dba_clu_columns b<br> WHERE<br>     a.owner = b.owner and<br>     a.cluster_name=b.cluster_name<br>ORDER BY 1,2,3,4<br>/<br>SPOOL OFF<br>
<i>Quellcode 10.28: Berichtsskript für Cluster</i><br>
<hr>
<A name=65></a>rem<br>rem Name     : clus_siz.sql<br>rem FUNCTION : Generate a cluster sizing report<br>rem<br>COLUMN owner           FORMAT a10<br>COLUMN cluster_name    FORMAT a15       HEADING &quot;Cluster&quot;<br>COLUMN tablespace_name FORMAT a15       HEADING &quot;Tablespace&quot;<br>COLUMN pct_free        FORMAT 999       HEADING &quot;%|Fre&quot;<br>COLUMN pct_used        FORMAT 999       HEADING &quot;%|Use&quot;<br>COLUMN key_size        FORMAT 999999    HEADING &quot;Key Size&quot;<br>COLUMN ini_trans       FORMAT 999       HEADING &quot;Ini|Trn&quot;<br>COLUMN max_trans       FORMAT 999       HEADING &quot;Max|Trn&quot;<br>COLUMN initial_extent  FORMAT 999999999 HEADING &quot;Init Ext&quot;<br>COLUMN next_extent     FORMAT 999999999 HEADING &quot;Next Ext&quot;<br>COLUMN min_extents     FORMAT 999       HEADING &quot;Min|Ext&quot;<br>COLUMN max_extents     FORMAT 999       HEADING &quot;Max|Ext&quot;<br>COLUMN pct_increase    FORMAT 999       HEADING &quot;%|Inc&quot;<br>SET PAGES 56 LINES 130 FEEDBACK OFF<br>START title132 &quot;Cluster Sizing Report&quot;<br>BREAK ON owner ON tablespace_name<br>SPOOL rep_out\&amp;db\cls_sze<br>SELECT<br>     owner,<br>     tablespace_name,<br>     cluster_name,<br>     pct_free,<br>     pct_used,<br>     key_size,<br>     ini_trans,<br>     max_trans,<br>     initial_extent,<br>     next_extent,<br>     min_extents,<br>     max_extents,<br>     pct_increase<br> FROM<br>     dba_clusters<br> ORDER BY<br>     1,2,3<br>/<br>SPOOL OFF<br>CLEAR COLUMNS<br>CLEAR BREAKS<br>SET PAGES 22 LINES 80 FEEDBACK ON<br>PAUSE Press enter to continue<br>
<i>Quellcode 10.29: Berichtsskript für die Größenermittlung von Clustern</i><br>
<hr>
<A name=66></a>rem  Name    : clu_stat.sql<br>rem  Purpose : Report on new DBA_CLUSTER columns<br>rem  Use     : From an account that accesses DBA_ views<br>rem<br>COLUMN owner              FORMAT a10    HEADING &quot;Owner&quot;<br>COLUMN cluster_name       FORMAT a15    HEADING &quot;Cluster&quot;<br>COLUMN tablespace_name    FORMAT a10    HEADING &quot;Tablespace&quot;<br>COLUMN avg_blocks_per_key FORMAT 999999 HEADING &quot;Blocks per Key&quot;<br>COLUMN cluster_type       FORMAT a8     HEADING &quot;Type&quot;<br>COLUMN function           FORMAT 999999 HEADING &quot;Function&quot;<br>COLUMN hashkeys           FORMAT 99999  HEADING &quot;# of Keys&quot;<br>SET PAGES 56 LINES 79 FEEDBACK OFF<br>START title80 &quot;Cluster Statistics Report&quot;<br>SPOOL report_output/&amp;db/clu_type<br>SELECT<br>     owner,<br>     cluster_name,<br>     tablespace_name,<br>     avg_blocks_per_key,<br>     cluster_type,<br>     function,<br>     hashkeys<br> FROM<br>     dba_clusters<br> ORDER BY 2<br> GROUP BY owner, tablespace, type<br>/<br>SPOOL OFF<br>SET PAGES 22 LINES 80 FEEDBACK ON<br>CLEAR COLUMNS<br>TTITLE OFF<br>
<i>Quellcode 10.30: Berichtsskript für die neuen </i>DBA_CLUSTERS<i>-Spalten</i><br>
<hr>
<A name=67></a>rem<br>rem  Name    : mv_rep.sql<br>rem  Purpose :Report on database Materialized views<br>rem  Use     : From an account that accesses DBA_MVIEWS<br>rem<br>rem When      Who        What<br>rem -------   ---------  ----------------<br>rem 5/27/93   Mike Ault  Initial Creation<br>rem 10/10/01  Mike Ault  Update to 9i<br>rem<br>SET PAGES 56 LINES 130 FEEDBACK OFF VERIFY OFF<br>rem<br>COLUMN mv        FORMAT a30   HEADING &quot;Materialized|View&quot;<br>COLUMN source    FORMAT a30   HEADING &quot;Source Table&quot;<br>COLUMN log                    HEADING &quot;Use|Log?"<br>COLUMN type      FORMAT a10   HEADING &quot;Ref|Type&quot;<br>COLUMN refreshed              HEADING &quot;Last Refresh&quot;<br>COLUMN start     FORMAT a13   HEADING &quot;Start Refresh&quot;<br>COLUMN error                  HEADING &quot;Error&quot;<br>COLUMN next      FORMAT a13   HEADING &quot;Next Refresh&quot;<br>rem<br>PROMPT Percent signs are wild card<br>ACCEPT mv_owner PROMPT Enter the materialized view owner<br>START title132 &quot;Materialized View Report for &amp;mv_owner&quot;<br>SPOOL rep_out/&amp;db/mv_rep&amp;db<br>rem<br>SELECT<br>     Owner||'.'||mview_name mv, master_view,<br>     master_link Source,<br>     substr(query,1,query_len) query,<br>     updatable,<br>     update_log Log, last_refresh_date Refreshed,<br>     DECODE(refresh_mode,'FAST','F','COMPLETE','C','FORCE',<br>            'FR','COMMIT','CM'),<br>     query,<br>     master_rollback_segment rbk<br> FROM dba_mviews<br> WHERE owner LIKE UPPER('%&amp;mv_owner%')<br> ORDER BY owner,mview_name;<br>rem<br>SPOOL OFF<br>
<i>Quellcode 10.31: Skript zur Dokumentation von materialisierten Sichten und Log-Dateien zu materialisierten Sichten</i><br>
rem<br>rem  Name    : mv_log_rep.sql<br>rem  Purpose : Report on database materialized view Logs<br>rem  Use     : From an account that accesses DBA_ views<br>rem<br>rem  When      Who        What<br>rem  -------   ---------  -------------------<br>rem  5/27/93   Mike Ault  Initial Creation<br>rem  10/10/01  Mike Ault  Updated to oracle9i<br>rem<br>SET PAGES 56 LINES 130 FEEDBACK OFF<br>START title132 &quot;Materialized View Log Report&quot;<br>SPOOL rep_out/&amp;db/mv_log_rep&amp;db<br>rem<br>COLUMN log_owner  FORMAT a10   HEADING &quot;Owner&quot;<br>COLUMN master     FORMAT a20   HEADING &quot;Master&quot;<br>COLUMN log_table  FORMAT a20   HEADING &quot;Materialized View&quot;<br>COLUMN trigger    FORMAT a20   HEADING &quot;Trigger Text&quot;<br>COLUMN current                 HEADING &quot;Last Refresh&quot;<br>rem<br>
<hr>
<A name=68></a>SELECT<br>     log_owner, master, log_table table,<br>     log_trigger trigger, rowids, filter_columns filtered,<br>     object_id id, sequence seq,Include_new_values new<br> FROM<br>     dba_mview_logs<br> ORDER BY 1;<br>rem<br>SPOOL OFF<br>CLEAR COLUMNS<br>SET FEEDBACK ON<br>TTITLE OFF<br>
<i>Quellcode 10.32: Berichtsskript für Log-Dateien zu materialisierten Sichten</i><br>
<hr>
<A name=69></a>rem<br>rem  NAME     : types.sql<br>rem  FUNCTION : Provide basic report of all database types<br>rem             for a specific owner or all owners<br>rem  HISTORY  : MRA 6/15/97 Created<br>rem<br>COLUMN owner            FORMAT a10   HEADING 'Type|Owner'<br>COLUMN type_name        FORMAT a15   HEADING 'Type|Name'<br>COLUMN typecode         FORMAT a11   HEADING 'Type|Code'<br>COLUMN predefined       FORMAT a3    HEADING Pre?<br>COLUMN incomplete       FORMAT a3    HEADING Inc?<br>COLUMN methods          FORMAT 9999  HEADING '#|Methods'<br>COLUMN attributes       FORMAT 9999  HEADING '#|Attrib'<br>COLUMN final            FORMAT A5    HEADING 'Final'<br>COLUMN instantiable     FORMAT A5    HEADING 'Inst.'<br>COLUMN supertype_owner  FORMAT a10   HEADING 'SuperType|Owner'<br>COLUMN supertype_name   FORMAT a15   HEADING 'SuperType|Name'<br>COLUMN local_attributes FORMAT 99999 HEADING 'Local|Attri'<br>COLUMN local_methods    FORMAT 99999 HEADING 'Local|Meth'<br>SET LINES 130 PAGES 58 VERIFY OFF FEEDBACK OFF<br>BREAK ON owner<br>START title132 'Database Types Report'<br>SPOOL rep_out\&amp;db\types.lis<br>SELECT<br>     DECODE(owner, null,'SYS-GEN',owner) owner,<br>     type_name,<br>     typecode,<br>     attributes,<br>     methods,<br>     predefined,<br>     incomplete,<br>     final,<br>     Instantiable,<br>     Supertype_owner,<br>     Supertype_name,<br>     local_attributes,<br>     local_methods<br> FROM dba_types<br> WHERE owner LIKE '%&amp;owner%'<br> ORDER BY owner, type_name;<br>SPOOL OFF<br>TTITLE OFF<br>SET VERIFY ON FEEDBACK ON LINES 80 PAGES 22<br>CLEAR COLUMNS<br>CLEAR BREAKS<br>
<i>Quellcode 10.33: Berichtsskript für Typen</i><br>
<hr>
<A name=70></a>rem<br>rem NAME     : coll_type.sql<br>rem FUNCTION : Document the collection types in the database<br>rem            for a specified user or all users<br>rem HISTORY  : MRA  6/15/97  Created<br>rem            MRA 10/10/01  Updated to 9i<br>rem<br>COL owner           FORMAT a10  HEADING 'Collec.|Owner'<br>COL type_name       FORMAT a16  HEADING 'Type|Name'<br>COL coll_type       FORMAT a15  HEADING 'Collec.|Type'<br>COL upper_bound                 HEADING 'VARRAY|Limit'<br>COL elem_type_owner FORMAT a10  HEADING 'Elementary|Type|Owner'<br>COL elem_type_name  FORMAT a11  HEADING 'Elementary|Type|Name'<br>SET PAGES 58 LINES 130 VERIFY OFF FEEDBACK OFF<br>START title132 'Collection Type Report'<br>SPOOL rep_out\&amp;db\col_type.lis<br>SELECT<br>     owner,<br>     type_name,<br>     coll_type,<br>     upper_bound,<br>     elem_type_mod,<br>     elem_type_owner,<br>     elem_type_name,<br>     length,<br>     precision,<br>     scale,<br>     elem_storage,<br>     nulls_stored<br> FROM dba_coll_types<br> WHERE owner LIKE '%&amp;owner%'<br>/<br>SPOOL OFF<br>CLEAR COLUMNS<br>CLEAR BREAKS<br>TTILTE OFF<br>SET VERIFY ON FEEDBACK ON<br>
<i>Quellcode 10.34: Dieses Skript erzeugt einen Bericht wie den in Listing 10.32</i><br>
<hr>
<A name=71></a>rem<br>rem NAME     : typ_meth.sql<br>rem FUNCTION : Create a report of type methods for a<br>rem            specific user or all users<br>rem HISTORY  : MRA  6/16/97  Created<br>rem            MRA 10/10/01  Updated to 9i<br>rem<br>COLUMN owner         FORMAT a10    HEADING 'Owner'<br>COLUMN type_name     FORMAT a25    HEADING 'Type|Name'<br>COLUMN method_name   FORMAT a25    HEADING 'Method|Name'<br>COLUMN method_type                 HEADING 'Method|Type'<br>COLUMN parameters    FORMAT 99999  HEADING '#|Param'<br>COLUMN results       FORMAT 99999  HEADING '#|Results'<br>COLUMN method_no     FORMAT 99999  HEADING 'Meth.|Number'<br>COLUMN final         FORMAT A5     HEADING 'Final'<br>COLUMN Instantiable  FORMAT A6     HEADING 'Instan'<br>COLUMN overriding    FORMAT A6     HEADING 'ORide?'<br>COLUMN Inherited     FORMAT A9     HEADING 'Inherited'<br>BREAK ON owner ON type_name<br>SET LINES 132 PAGES 58 VERIFY OFF FEEDBACK OFF<br>START title132 'Type Methods Report'<br>SPOOL rep_out\&amp;db\typ_meth.lis<br>SELECT<br>     owner,<br>     type_name,<br>     method_name,<br>     method_no,<br>     method_type,<br>     parameters,<br>     results,<br>     final,<br>     Instantiable,<br>     Overriding,<br>     Inherited<br> FROM dba_type_methods<br> WHERE owner LIKE UPPER('%&amp;owner%')<br> ORDER BY owner, type_name;<br>SPOOL OFF<br>CLEAR COLUMNS<br>CLEAR BREAKS<br>SET VERIFY ON FEEDBACK ON LINES 80 pages 22<br>TTITLE OFF<br>
<i>Quellcode 10.35: Berichtsskript für Typmethoden</i><br>
<hr>
<A name=72></a>rem<br>rem NAME     : tab_ref.sql<br>rem FUNCTION : Generate a lit of all REF columns in the database<br>rem            for a specific user or all users<br>rem HISTORY  : MRA 6/16/97 Created<br>rem<br>COLUMN owner             FORMAT a8  HEADING 'Owner'<br>COLUMN table_name        FORMAT a23 HEADING 'Table|Name'<br>COLUMN column_name       FORMAT a15 HEADING 'Column|Name'<br>COLUMN with_rowid        FORMAT a5  HEADING 'With|Rowid'<br>COLUMN is_scoped         FORMAT a6  HEADING 'Scoped'<br>COLUMN scope_table_owner FORMAT a8  HEADING 'Scope|Table|Owner'<br>COLUMN scope_table_name  FORMAT a15 HEADING 'Scope|Table|Name'<br>BREAK ON owner<br>SET PAGES 58 LINES 130 FEEDBACK OFF VERIFY OFF<br>START title132 'Database REF Report'<br>SPOOL rep_out\&amp;db\tab_ref.lis<br>SELECT<br>     owner,<br>     table_name,<br>     column_name,<br>     with_rowid,<br>     is_scoped,<br>     scope_table_owner,<br>     scope_table_name<br> FROM<br>     dba_refs<br> WHERE<br>     Owner LIKE UPPER('%&amp;owner%')<br> ORDER BY<br>     owner;<br>SPOOL OFF<br>SET FEEDBACK ON VERIFY ON<br>CLEAR COLUMNS<br>CLEAR BREAKS<br>TTITLE OFF<br>
<i>Quellcode 10.36: Berichtsskript für </i>REF<i>-Spalten</i><br>
<hr>
<A name=73></a>rem<br>rem NAME     : operator.sql<br>rem FUNCTION : Generate a lit of all OPERATORS in the database<br>rem            for a specific user or all users<br>rem HISTORY  : MRA 5/12/98 Created<br>rem<br>COLUMN owner           FORMAT a8   HEADING 'Owner'<br>COLUMN operator_name   FORMAT a10  HEADING 'Operator|Name'<br>COLUMN number_of_binds FORMAT 9999 HEADING 'Binds'<br>COLUMN position                    HEADING 'Position'<br>COLUMN argument_type   FORMAT A20  HEADING 'Argument|Type'<br>COLUMN function_name   FORMAT A20  HEADING 'Binding|Argument'<br>COLUMN return_schema   FORMAT A10  HEADING 'Return|Schema'<br>COLUMN return_type     FORMAT A20  HEADING 'Return|Type'<br>BREAK ON owner ON operator_name ON number_of_binds<br>SET PAGES 58 LINES 130 FEEDBACK OFF VERIFY OFF<br>START title132 'Database OPERATOR Report'<br>SPOOL rep_out\&amp;db\operator.lis<br>SELECT<br>     a.owner,<br>     a.operator_name,<br>     a.number_of_bindings,<br>     b.position,<br>     b.argument_type,<br>     c.function_name,<br>     DECODE(c.return_schema,NULL,'Internal',c.return_schema) return_schema,<br>     c.return_type<br> FROM<br>     Dba_operators a, dba_oparguments b, dba_opbindings c<br> WHERE<br>     Owner LIKE '%&amp;owner%'<br>     AND a.owner=b.owner<br>     AND a.operator_name=b.operator_name<br>     AND a.owner=c.owner<br>     AND a.operator_name=c.operator_name<br>     AND b.binding#=c.binding#;<br>SPOOL OFF<br>CLEAR BREAKS<br>CLEAR COLUMNS<br>TTITLE OFF<br>SET FEEDBACK ON VERIFY ON<br>
<i>Quellcode 10.37: Berichtsskript für Operatoren in der Datenbank</i><br>
<hr>
<A name=74></a>rem<br>rem NAME     : dim_level.sql<br>rem FUNCTION : Generate a lit of all Dimensions and levels in the<br>rem            database for a specific user or all users<br>rem HISTORY  : MRA 5/12/98 Created<br>rem<br>COLUMN owner           FORMAT a8    HEADING 'Owner'<br>COLUMN dimension_name  FORMAT a10   HEADING 'Dimension|Name'<br>COLUMN level_name      FORMAT a10   HEADING 'Level|Name'<br>COLUMN column_name     FORMAT a20   HEADING 'Column|Name'<br>COLUMN key_position    FORMAT 9999  HEADING 'Key|Position'<br>BREAK ON owner ON operator_name ON number_of_binds<br>SET PAGES 58 LINES 130 FEEDBACK OFF VERIFY OFF<br>START title132 'Database Dimension Levels Report'<br>SPOOL rep_out\&amp;db\dim_level.lis<br>SELECT<br>     a.owner,<br>     a.dimension_name,<br>     b.level_name,<br>     c.column_name,<br>     c.key_position<br> FROM<br>     Dba_dimensions a, dba_dim_levels b, dba_dim_level_key c<br> WHERE<br>     a.Owner LIKE '%&amp;owner%'<br>     AND a.owner=b.owner<br>     AND a.dimension_name=b.dimension_name<br>     AND a.owner=c.owner<br>     AND a.dimension_name=c.dimension_name<br>     AND b.level_name=c.level_name<br> ORDER BY<br>     a.owner,<br>     a.dimension_name,<br>     b.level_name;<br>SPOOL OFF<br>CLEAR BREAKS<br>CLEAR COLUMNS<br>TTITLE OFF<br>SET FEEDBACK ON VERIFY ON<br>
<i>Quellcode 10.38: Berichtsskript für Dimensionsebenen einer Datenbank</i><br>
<hr>
<A name=75></a>rem<br>rem NAME     : dim_hierarchies.sql<br>rem FUNCTION : Generate a lit of all dimensions and hierarchies in the<br>rem            database for a specific user or all users<br>rem HISTORY  : MRA 5/12/98 Created<br>rem<br>COLUMN owner              FORMAT a8   HEADING 'Owner'<br>COLUMN dimension_name     FORMAT a10  HEADING 'Dimension|Name'<br>COLUMN column_name        FORMAT a10  HEADING 'Column|Name'<br>COLUMN hierarchy_name     FORMAT a10  HEADING 'Hierarchy|Name'<br>COLUMN parent_level_name  FORMAT a10  HEADING 'Parent|Level'<br>COLUMN child_level_name   FORMAT a10  HEADING 'Child|Level'<br>COLUMN join_key_id        FORMAT a20  HEADING 'Join Key|ID'<br>BREAK ON owner ON dimension_name<br>SET PAGES 58 LINES 78 FEEDBACK OFF VERIFY OFF<br>START title80 'Database Dimension Hierarchy Report'<br>SPOOL rep_out\&amp;db\dim_hierarchies.lis<br>SELECT<br>     a.owner,<br>     a.dimension_name,<br>     b.hierarchy_name,<br>     c.parent_level_name,<br>     c.child_level_name,<br>     c.join_key_id<br> FROM<br>     Dba_dimensions a, dba_dim_hierarchies b, dba_dim_child_of c<br> WHERE<br>     a.Owner LIKE '%&amp;owner%'<br>     AND a.owner=b.owner<br>     AND a.dimension_name=b.dimension_name<br>     AND a.owner=c.owner<br>     AND a.dimension_name=c.dimension_name<br>     AND b.hierarchy_name=c.hierarchy_name<br> ORDER BY<br>     a.owner,<br>     a.dimension_name,<br>     b.hierarchy_name;<br>SPOOL OFF<br>CLEAR BREAKS<br>CLEAR COLUMNS<br>TTITLE OFF<br>SET FEEDBACK ON VERIFY ON<br>
<i>Quellcode 10.39: Berichtsskript für die Dimensionshierarchie einer Datenbank</i><br>
<hr>
<A name=76></a>rem<br>rem NAME     : dim_attribute.sql<br>rem FUNCTION : Generate a lit of all Dimensions and atrributes in the<br>rem            database for a specific user or all users<br>rem HISTORY  : MRA 5/12/98 Created<br>rem<br>COLUMN owner           FORMAT a8   HEADING 'Owner'<br>COLUMN dimension_name  FORMAT a10  HEADING 'Dimension|Name'<br>COLUMN column_name     FORMAT a20  HEADING 'Column|Name'<br>COLUMN level_name      FORMAT a20  HEADING 'Level|Name'<br>COLUMN inferred        FORMAT a10  HEADING 'Inferred'<br>BREAK ON owner ON level_name<br>SET PAGES 58 LINES 78 FEEDBACK OFF VERIFY OFF<br>START title80 'Database OPERATOR Report'<br>SPOOL rep_out\&amp;db\dim_attribute.lis<br>SELECT<br>     a.owner,<br>     a.dimension_name,<br>     b.level_name,<br>     c.column_name,<br>     c.inferred<br> FROM<br>     Dba_dimensions a, dba_dim_levels b, dba_dim_attributes c<br> WHERE<br>     a.owner LIKE '%&amp;owner%'<br>     AND a.owner=b.owner<br>     AND a.dimension_name=b.dimension_name<br>     AND a.owner=c.owner<br>     AND a.dimension_name=c.dimension_name<br>     AND b.level_name=c.level_name<br> ORDER BY<br>     a.owner,<br>     a.dimension_name,<br>     b.level_name;<br>SPOOL OFF<br>CLEAR BREAKS<br>CLEAR COLUMNS<br>TTITLE OFF<br>SET FEEDBACK ON VERIFY ON<br>
<i>Quellcode 10.40: Berichtsskript für die Dimensionsattribute einer Datenbank</i><br>
<hr>
<A name=77></a>rem<br>rem NAME     : outline.sql<br>rem FUNCTION : Generate a lit of all outlines in the<br>rem            database for a specific user or all users<br>rem HISTORY  : MRA 5/13/98 Created<br>rem<br>COLUMN owner      FORMAT a8   HEADING 'Owner'<br>COLUMN name       FORMAT a13  HEADING 'Outline|Name'<br>COLUMN category   FORMAT a8   HEADING 'Category|Name'<br>COLUMN used       FORMAT a7   HEADING 'Used?'<br>COLUMN timestamp  FORMAT a16  HEADING 'Date Last|Used'<br>COLUMN version    FORMAT a9   HEADING 'Version'<br>COLUMN sql_text   FORMAT a40  HEADING 'SQL Outlined' WORD_WRAPPED<br>BREAK ON owner ON category<br>SET PAGES 58 LINES 130 FEEDBACK OFF VERIFY OFF<br>START title132 'Database OUTLINE Report'<br>SPOOL rep_out\&amp;db\outline.lis<br>SELECT<br>     owner,<br>     name,<br>     category,<br>     used,<br>     to_char(timestamp,'dd/mm/yyyy hh24:mi') timestamp,<br>     version,<br>     sql_text<br> FROM<br>     Dba_outlines<br> WHERE<br>     Owner LIKE '%&amp;owner%'<br> ORDER BY<br>     owner,category;<br>SPOOL OFF<br>CLEAR BREAKS<br>TTITLE OFF<br>SET FEEDBACK ON VERIFY ON<br>
<i>Quellcode 10.41: Berichtsskript für Outlines der Datenbank</i><br>
<hr>
<A name=78></a>rem<br>rem NAME     : outline_hint.sql<br>rem FUNCTION : Generate a lit of all outlines in the<br>rem            database for a specific user and outline<br>rem            or all users and outlines<br>rem HISTORY  : MRA 5/13/98  Created<br>rem<br>COLUMN owner     FORMAT a8    HEADING 'Owner'<br>COLUMN name      FORMAT a13   HEADING 'Outline|Name'<br>COLUMN category  FORMAT a10   HEADING 'Category|Name'<br>COLUMN node      FORMAT 9999  HEADING 'Node'<br>COLUMN join_pos  FORMAT 9999  HEADING 'Join|Pos'<br>COLUMN hint      FORMAT A27   HEADING 'Hint Text' WORD_WRAPPED<br>BREAK ON owner ON category ON name<br>SET PAGES 58 LINES 78 FEEDBACK OFF VERIFY OFF<br>START title80 'Database OUTLINE Report'<br>SPOOL rep_out\&amp;db\outline_hint.lis<br>SELECT<br>     a.owner, a.name,<br>     a.category, b.node,<br>     b.join_pos, b.hint<br> FROM<br>     Dba_outlines a, dba_outline_hints b<br> WHERE<br>     a.Owner LIKE UPPER('%&amp;owner%')<br>     AND a.name LIKE UPPER('%&amp;outline%')<br>     AND a.owner=b.owner<br>     AND a.name=b.name<br> ORDER BY<br>     owner,category,name,b.node;<br>SPOOL OFF<br>CLEAR BREAKS<br>TTITLE OFF<br>SET FEEDBACK ON VERIFY ON<br>
<i>Quellcode 10.42: Berichtsskript für die Outline-Hinweise einer Datenbank</i><br>
REM<br>REM NAME        : DB_USER.SQL<br>REM<br>REM FUNCTION    : GENERATE USER_REPORT<br>REM Limitations : None<br>REM<br>REM Updates     : MRA 6/10/97 added Oracle8 account status<br>REM               MRA 5/14/99 Added Oracle8i  Resource Group<br>REM               MRA 5/22/99 Removed expiry data to new report<br>REM<br>SET PAGESIZE 58  LINESIZE 131 FEEDBACK OFF<br>REM<br>COLUMN username                 FORMAT a12 HEADING User<br>COLUMN account_status           FORMAT a6  HEADING Status<br>COLUMN default_tablespace       FORMAT a14 HEADING Default<br>COLUMN temporary_tablespace     FORMAT a10 HEADING Temporary<br>COLUMN granted_role             FORMAT a22 HEADING Roles<br>COLUMN default_role             FORMAT a8  HEADING Default?<br>COLUMN admin_option             FORMAT a6  HEADING Admin?<br>COLUMN profile                  FORMAT a10 HEADING Profile<br>COLUMN initial_rsrc_consumer_group FORMAT a22 HEADING 'Resource|Group'<br>REM<br>START title132 'ORACLE USER REPORT'<br>DEFINE output = rep_out\&amp;db\db_user<br>BREAK ON username SKIP 1 ON default_tablespace ON temporary_tablespace ON profile <br>ON account_status ON initial_rsrc_consumer_group<br>SPOOL &amp;output<br>REM<br>
<hr>
<A name=79></a>SELECT a.username,<br>       a.default_tablespace,a.temporary_tablespace,<br>       a.profile,a.account_status,<br>       a.initial_rsrc_consumer_group,<br>       b.granted_role,b.admin_option,<br>       b.default_role<br> FROM sys.dba_users a,<br>      sys.dba_role_privs b<br> WHERE a.username = b.grantee<br> ORDER BY username,<br>          default_tablespace,<br>          temporary_tablespace,<br>          profile,<br>          granted_role;<br>REM<br>SPOOL OFF<br>SET TERMOUT ON FLUSH ON FEEDBACK ON VERIFY ON CLEAR COLUMNS<br>CLEAR BREAKS<br>PAUSE Press Enter to continue<br>
<i>Quellcode 11.1: Beispielskript für einen Benutzerbericht</i><br>
REM<br>REM NAME        : DB_USER.SQL<br>REM<br>REM FUNCTION    : GENERATE USER_REPORT<br>REM Limitations : None<br>REM<br>REM Updates     : MRA 6/10/97 added Oracle8 account status<br>REM               MRA 5/14/99 Added Oracle8i Resource Group<br>REM<br>SET PAGESIZE 58 LINESIZE 131 FEEDBACK OFF<br>REM<br>COLUMN username                 FORMAT a10 HEADING User<br>COLUMN account_status           FORMAT a10 HEADING Status<br>COLUMN default_tablespace       FORMAT a15 HEADING Default<br>COLUMN temporary_tablespace     FORMAT a15 HEADING Temporary<br>COLUMN granted_role             FORMAT a21 HEADING Roles<br>COLUMN default_role             FORMAT a9  HEADING Default?<br>COLUMN admin_option             FORMAT a7  HEADING Admin?<br>COLUMN profile                  FORMAT a15 HEADING Profile<br>COLUMN initial_rsrc_consumer_group FORMAT a10 HEADING 'Resource|Group'<br>COLUMN lock_date                           HEADING 'Date|Locked'<br>COLUMN expiry_date                         HEADING 'Expiry_date'<br>REM<br>START title132 'ORACLE USER REPORT'<br>DEFINE output = rep_out\&amp;db\db_user<br>BREAK ON username SKIP 1 ON account_status ON default_tablespace<br>ON temporary_tablespace ON profile<br>SPOOL &amp;output<br>REM<br>SELECT a.username,<br>       a.account_status,<br>       TO_CHAR(a.lock_date,'dd-mon-yyyy hh24:mi') lock_date,<br>       TO_CHAR(a.expiry_date,'dd-mon-yyyy hh24:mi') expiry_date,<br>       a.default_tablespace,a.temporary_tablespace,<br>       a.profile,b.granted_role,<br>       b.admin_option,b.default_role,<br>       a.initial_rsrc_consumer_group<br> FROM sys.dba_users a,<br>      sys.dba_role_privs b<br> WHERE a.username = b.grantee<br> ORDER BY username,<br>          default_tablespace,temporary_tablespace,<br>          profile, granted_role;<br>REM<br>SPOOL OFF<br>SET TERMOUT ON FLUSH ON FEEDBACK ON VERIFY ON<br>
<hr>
<A name=80></a>CLEAR COLUMNS<br>CLEAR BREAKS<br>PAUSE Press Enter to continue<br>
<i>Quellcode 11.2: Beispielskript für einen Benutzerbericht</i><br>
<hr>
<A name=81></a>REM<br>REM NAME        : USER_EXPIRE.SQL<br>REM<br>REM FUNCTION    : GENERATE USER EXPIRY DATA REPORT<br>REM Limitations : None<br>REM<br>REM Updates     : MRA 5/22/99 Created<br>REM<br>COLUMN account_status        FORMAT a15 HEADING Status<br>COLUMN default_tablespace    FORMAT a14 HEADING Default<br>COLUMN temporary_tablespace  FORMAT a10 HEADING Temporary<br>COLUMN username              FORMAT a12 HEADING User<br>COLUMN lock_date             FORMAT a11 HEADING 'Date|Locked'<br>COLUMN expiry_date           FORMAT a11 HEADING 'Expiry|Date'<br>COLUMN profile               FORMAT a15 HEADING Profile<br>SET PAGESIZE 58 LINESIZE 131 FEEDBACK OFF<br>START title132 'ORACLE USER EXPIRATION REPORT'<br>BREAK ON username SKIP 1 ON default_tablespace ON temporary_tablespace ON<br>profile ON account_status<br>SPOOL rep_out\&amp;db\user_expire<br>rem<br>SELECT username,<br>       default_tablespace,temporary_tablespace,<br>       profile,account_status,<br>       TO_CHAR(lock_date,'dd-mon-yyyy') lock_date,<br>       TO_CHAR(expiry_date,'dd-mon-yyyy') expiry_date<br> FROM sys.dba_users<br> ORDER BY username,<br>          default_tablespace,temporary_tablespace,<br>          profile, account_status;<br>rem<br>SPOOL OFF<br>SET TERMOUT ON FLUSH ON FEEDBACK ON VERIFY ON<br>CLEAR COLUMNS<br>CLEAR BREAKS<br>PAUSE Press Enter to continue<br>
<i>Quellcode 11.3: Beispielskript für einen Bericht über den Verfallsstatus von Accounts</i><br>
<hr>
<A name=82></a>REM<br>REM NAME        : sys_role.SQL<br>REM PURPOSE     : GENERATE SYSTEM GRANTS and ROLES REPORT<br>REM USE         : CALLED BY SQLPLUS<br>REM Limitations : None<br>REM Revisions   :<br>REM Date          Modified by  Reason for change<br>REM 08-Apr-1993   MIKE AULT    INITIAL CREATE<br>REM 10-Jun-1997   Mike Ault    Update to Oracle8<br>REM 15-May-1999   Mike Ault    No changes for Oracle8i<br>REM<br>SET FLUSH OFF TERM OFF PAGESIZE 58 LINESIZE 78<br>COLUMN grantee          HEADING 'User or Role'<br>COLUMN admin_option     HEADING Admin?<br>START title80 'SYSTEM GRANTS AND ROLES REPORT'<br>DEFINE output = rep_out\&amp;&amp;db\role_report<br>SPOOL &amp;output<br>SELECT<br>     grantee,<br>     privilege,<br>     admin_option<br> FROM<br>     sys.dba_sys_privs<br> GROUP BY<br>     grantee;<br>SPOOL OFF<br>SET FLUSH ON TERM ON<br>CLEAR COLUMNS<br>TTITLE OFF<br>
<i>Quellcode 11.4: Beispielskript für einen Rollenbericht unter Oracle7, Oracle8 und Oracle8i</i><br>
<hr>
<A name=83></a>REM NAME       : PROFILE_REPORT.SQL<br>REM PURPOSE    : GENERATE USER PROFILES REPORT<br>REM Revisions  :<br>REM Date         Modified by     Reason for change<br>REM 08-Apr-1993  MIKE AULT       INITIAL CREATE<br>REM 14-May-1999  MIKE AULT       Added resource_type<br>REM<br>SET FLUSH OFF TERM OFF PAGESIZE 58 LINESIZE 78 VERIFY OFF FEEDBACK OFF<br>COLUMN profile          FORMAT a15  HEADING Profile<br>COLUMN resource_name    FORMAT A25  HEADING 'Resource:'<br>COLUMN resource_type    FORMAT A9   HEADING 'Resource|Affects'<br>COLUMN limit            FORMAT a20  HEADING Limit<br>START title80 'ORACLE PROFILES REPORT'<br>BREAK ON profile<br>SPOOL rep_out/&amp;&amp;db/prof_rep<br>SELECT<br>     profile,resource_name,<br>     resource_type,limit<br> FROM<br>     sys.dba_profiles<br> WHERE<br>     profile LIKE UPPER('%&amp;profile_name%')<br> ORDER BY<br>     profile,resource_type,resource_name;<br>SPOOL OFF<br>CLEAR COLUMNS<br>SET FLUSH ON TERM ON VERIFY ON FEEDBACK ON<br>TTITLE OFF<br>
<i>Quellcode 11.5: wSkript zum Generieren eines Ressourcenberichts für Benutzerprofile unter Oracle8, Oracle8i und  Oracle9i</i><br>
REM NAME       : RESOURCE_PLAN.SQL<br>REM PURPOSE    : GENERATE DATABASE RESOURCE PLAN REPORT<br>REM Revisions  :<br>REM Date         Modified by     Reason for change<br>REM 15-May-1999  MIKE AULT       initial creation<br>REM<br>COLUMN plan             FORMAT a16 HEADING 'Plan|Name'<br>COLUMN cpu_method1      FORMAT a8  HEADING 'CPU|Method'<br>COLUMN mandatory1       FORMAT a4  HEADING 'Man?'<br>COLUMN group_or_subplan FORMAT a12 HEADING 'Group or|Subplan Name'<br>COLUMN type             FORMAT a8  HEADING 'Group or|Subplan'<br>COLUMN cpu_method2      FORMAT a8  HEADING 'CPU|Method2'<br>COLUMN plan2 NOPRINT<br>COLUMN queue_meth1      FORMAT A12<br>COLUMN queue_meth2      FORMAT A12<br>COLUMN session_pool1    FORMAT A25 HEADING 'Sessions 1'<br>COLUMN session_pool2    FORMAT A25 HEADING 'Sessions 2'<br>REM<br>SET LINES 228 PAGES 55 VERIFY OFF FEEDBACK OFF<br>BREAK ON plan ON cpu_method1 ON mandatory1 ON num_plan_directives<br>START title132 'Resource Plan Report'<br>SPOOL rep_out\&amp;&amp;db\resource_plan.lis<br>REM<br>SELECT DISTINCT<br>     decode(b.plan,'',a.plan,b.plan) plan,<br>     a.active_sess_pool_mth session_pool1,<br>     a.parallel_degree_limit_mth parallel_meth1,<br>     a.queueing_mth queue_meth1,<br>     b.plan plan2,<br>     a.cpu_method cpu_method1,<br>     a.mandatory mandatory1,<br>     DECODE(b.group_or_subplan,'',d.consumer_group,<br>       b.group_or_subplan) group_or_subplan,<br>
<hr>
<A name=84></a>     DECODE(b.type,'CONSUMER_GROUP','GROUP',b.type) type,<br>     c.active_sess_pool_mth session_pool2,<br>     c.parallel_degree_limit_mth parallel_meth2,<br>     c.queueing_mth queue_meth2,<br>     decode(c.cpu_method,'',d.cpu_method,c.cpu_method) cpu_method2<br> FROM<br>     dba_rsrc_plans a, dba_rsrc_plan_directives b, dba_rsrc_plans c,<br>     dba_rsrc_consumer_groups d<br> WHERE<br>     a.plan=b.plan<br>     AND ((b.group_or_subplan = c.plan OR<br>     b.group_or_subplan = d.consumer_group))<br> ORDER BY<br>     2,5;<br>SPOOL OFF<br>CLEAR COLUMNS<br>SET VERIFY ON FEEDBACK ON LINES 80 PAGES 22<br>TTITLE OFF<br>
<i>Quellcode 11.6: Berichtsskript für Ressourcenpläne unter Oracle8i und Oracle9i</i><br>
REM NAME       : PLAN_DIRECTIVES.SQL<br>REM PURPOSE    : GENERATE DATABASE RESOURCE PLAN DIRECTIVES REPORT<br>REM Revisions  :<br>REM Date         Modified by     Reason for change<br>REM 15-May-1999  MIKE AULT       initial creation<br>REM 13-Oct-2001  Mike Ault       Update to 9i<br>REM<br>COLUMN plan                     FORMAT a17     HEADING 'Plan|Name'<br>COLUMN cpu_method1              FORMAT a8      HEADING 'CPU|Method'<br>COLUMN mandatory1               FORMAT a3      HEADING 'Man|?'<br>COLUMN num_plan_directives      FORMAT 999     HEADING 'Num|Dir'<br>COLUMN group_or_subplan         FORMAT a17     HEADING 'Group or|Subplan<br>Name'<br>COLUMN type                     FORMAT a5      HEADING 'Type'<br>COLUMN cpu_method2              FORMAT a8      HEADING 'CPU|Method'<br>COLUMN cpu_p1                   FORMAT 999     HEADING 'CPU|1%'<br>COLUMN cpu_p2                   FORMAT 999     HEADING 'CPU|2%'<br>COLUMN cpu_p3                   FORMAT 999     HEADING 'CPU|3%'<br>COLUMN cpu_p4                   FORMAT 999     HEADING 'CPU|4%'<br>COLUMN cpu_p5                   FORMAT 999     HEADING 'CPU|5%'<br>COLUMN cpu_p6                   FORMAT 999     HEADING 'CPU|6%'<br>COLUMN cpu_p7                   FORMAT 999     HEADING 'CPU|7%'<br>COLUMN cpu_p8                   FORMAT 999     HEADING 'CPU|8%'<br>COLUMN parallel_degree_limit_p1 FORMAT 9999999 HEADING 'Par|Degree'<br>COLUMN switch_group             FORMAT a15     HEADING 'Switch|Group'<br>COLUMN switch_time                             HEADING 'Switch|Time'<br>COLUMN switch_estimate                         HEADING 'Switch|Estimate'<br>COLUMN max_est_exec_time                       HEADING 'Max Est|Exec Time'<br>COLUMN undo_pool                               HEADING 'Undo|Pool'<br>COLUMN active_sess_pool_p1                     HEADING 'Active|Session|Pool'<br>COLUMN queueing_p1                             HEADING 'Queueing'<br>REM<br>SET LINES 200 PAGES 55 VERIFY OFF FEEDBACK OFF<br>BREAK ON plan on cpu_method1 on mandatory1 on num_plan_directives<br>START title132 'Resource Plan Directives Report'<br>SPOOL rep_out\&amp;&amp;db\plan_directives.lis<br>REM<br>SELECT DISTINCT<br>     a.plan,<br>     a.cpu_method cpu_method1,<br>     a.mandatory mandatory1,<br>     b.group_or_subplan,<br>     DECODE(b.type,'CONSUMER_GROUP','GROUP',b.type) type,<br>     c.cpu_method cpu_method2,<br>     b.cpu_p1,b.cpu_p2,b.cpu_p3,b.cpu_p4,<br>
<hr>
<A name=85></a>     b.cpu_p5,b.cpu_p6,b.cpu_p7,b.cpu_p8,<br>     b.active_sess_pool_p1,b.queueing_p1,<br>     b.parallel_degree_limit_p1,<br>     b.switch_group,b.switch_time,<br>     b.switch_estimate,b.max_est_exec_time,<br>     b.undo_pool<br> FROM<br>     dba_rsrc_plans a, dba_rsrc_plan_directives b, dba_rsrc_plans c,<br>     dba_rsrc_consumer_groups d<br> WHERE<br>     a.plan=b.plan<br>     AND ((b.group_or_subplan = c.plan OR<br>         b.group_or_subplan=d.consumer_group))<br>     AND b.status='ACTIVE'<br> ORDER BY<br>     1,4,5;<br>SPOOL OFF<br>CLEAR COLUMNS<br>SET VERIFY ON FEEDBACK ON<br>TTITLE OFF<br>
<i>Quellcode 11.7: Berichtsskript für Plandirektiven unter Oracle8i und Oracle9i</i><br>
REM NAME       : PLAN_SYS_GRANTS.SQL<br>REM PURPOSE    : GENERATE DATABASE RESOURCE PLAN SYSTEM GRANTS REPORT<br>REM Revisions  :<br>REM Date         Modified by     Reason for change<br>REM 15-May-1999  MIKE AULT       initial creation<br>REM<br>COLUMN privilege     FORMAT a30  HEADING 'Plan System Privilege'<br>COLUMN grantee       FORMAT a30  HEADING 'User or Role'<br>COLUMN admin_option  FORMAT a7   HEADING 'Admin?'<br>BREAK ON privilege<br>SET LINES 78 VERIFY OFF FEEDBACK OFF<br>START title80 'Resource Plan System Grants'<br>SPOOL rep_out\&amp;&amp;db\plan_sys_grants.lis<br>REM<br>SELECT<br>     privilege, grantee, admin_option<br> FROM<br>     Dba_rsrc_manager_system_privs<br> ORDER BY<br>     Privilege;<br>SPOOL OFF<br>SET VERIFY ON FEEDBACK ON<br>TTITLE OFF<br>
<i>Quellcode 11.8: Berichtsskript für Systemprivilegien bei Ressourcenplänen unter Oracle8i und Oracle9i</i><br>
<hr>
<A name=86></a>REM NAME       : PLAN_GROUP_GRANTS.SQL<br>REM PURPOSE    : GENERATE DATABASE RESOURCE PLAN GROUP GRANTS REPORT<br>REM Revisions  :<br>REM Date         Modified by     Reason for change<br>REM 15-May-1999  MIKE AULT       initial creation<br>REM<br>COLUMN granted_group  FORMAT a30  HEADING 'Granted Group'<br>COLUMN grantee        FORMAT a30  HEADING 'User or Role'<br>COLUMN grant_option   FORMAT a7   HEADING 'Admin?'<br>COLUMN initial_group  FORMAT a8   HEADING 'Initial?'<br>BREAK ON granted_group<br>SET LINES 78 VERIFY OFF FEEDBACK OFF<br>START title80 'Resource Plan Group Grants'<br>SPOOL rep_out\&amp;&amp;db\plan_group_grants.lis<br>REM<br>SELECT<br>     Granted_group, grantee, grant_option, initial_group<br> FROM<br>     Dba_rsrc_consumer_group_privs<br> ORDER BY<br>     Granted_group;<br>SPOOL OFF<br>SET VERIFY ON FEEDBACK ON<br>TTITLE OFF<br>
<i>Quellcode 11.9: Berichtsskript für Gruppenrechte bei Ressourcenplänen unter Oracle8i und Oracle9i</i><br>
<hr>
<A name=87></a>rem PURPOSE     : Produce report of table grants showing<br>rem               GRANTOR, GRANTEE and specific GRANTS.<br>rem LIMITATIONS : User must have access to DBA_TAB_PRIVS<br>rem INPUTS      : Owner name<br>rem OUTPUTS     : Report of table grants<br>rem<br>rem HISTORY     :<br>rem Who:          What:                 Date:<br>rem Mike Ault     Initial creation      3/2/95<br>rem Mike Ault     Oracle8 verified      6/10/97<br>rem Mike Ault     Oracle8i verified     5/15/99<br>rem Mike Ault     Oracle9i Updated      13/10/01<br>rem<br>rem<br>COLUMN GRANTEE     FORMAT A19  HEADING &quot;Grantee&quot;<br>COLUMN OWNER       FORMAT A10  HEADING &quot;Owner&quot;<br>COLUMN TABLE_NAME  FORMAT A26  HEADING &quot;Table&quot;<br>COLUMN GRANTOR     FORMAT A10  HEADING &quot;Grantor&quot;<br>COLUMN PRIVILEGE   FORMAT A10  HEADING &quot;Privilege&quot;<br>COLUMN GRANTABLE   FORMAT A6   HEADING &quot;With|Grant|Option?&quot;<br>COLUMN HIERARCHY   FORMAT A3   HEADING 'HRY'<br>REM<br>BREAK ON owner SKIP 2 ON table_name ON grantee ON grantor ON REPORT<br>REM<br>SET LINESIZE 100 PAGES 56 VERIFY OFF FEEDBACK OFF<br>START title132 &quot;TABLE GRANTS BY OWNER AND TABLE&quot;<br>SPOOL rep_out\&amp;db\tab_grants<br>REM<br>SELECT<br>     owner,table_name,grantee,grantor,<br>     privilege,grantable,hierarchy<br> FROM<br>     dba_tab_privs<br> WHERE<br>     owner LIKE UPPER('%&amp;owner&amp;')<br>     AND privilege !='EXECUTE'<br> ORDER BY<br>     owner,table_name,grantor,grantee;<br>REM<br>SPOOL OFF<br>PAUSE Press Enter to continue<br>SET LINESIZE 80 PAGES 22 VERIFY ON FEEDBACK ON<br>CLEAR BREAKS<br>CLEAR COLUMNS<br>TTITLE OFF<br>
<i>Quellcode 11.10: Berichtsskript für Tabellenrechte unter Oracle9i</i><br>
<hr>
<A name=88></a>REM FUNCTION: SCRIPT FOR CAPTURING TABLE COLUMN GRANTS<br>REM<br>REM This script is intended to run with Oracle7,Oracle8 or Oracle9.<br>REM<br>REM Running this script will create a script of all the grants<br>REM on columns<br>REM<br>REM Grants must be made by the original grantor so the script<br>REM connects as that user using the username as the password<br>REM edit the proper password in at time of running<br>REM<br>REM NOTE: Grants made to 'SYS','CONNECT','RESOURCE','DBA',<br>REM       'EXP_FULL_DATABASE','IMP_FULL_DATABASE' are not captured.<br>REM<br>REM       Only preliminary testing of this script was performed.<br>REM       Be sure to test it completely before relying on it.<br>REM<br>SET VERIFY OFF FEEDBACK OFF TERMOUT OFF ECHO OFF PAGESIZE 0<br>SET EMBEDDED ON HEADING OFF<br>SET TERMOUT ON<br>PROMPT Creating table grant script...<br>SET TERMOUT OFF<br>DEFINE cr=CHR(10);<br>BREAK ON line1<br>COLUMN dbname NEW_VALUE db NOPRINT<br>SELECT name dbname FROM v$database;<br>SPOOL rep_out\&amp;db\grt_cols.sql<br>rem<br>SELECT<br>     'CONNECT '||grantor||'/'||grantor line1,<br>     'GRANT '||&amp;&amp;cr||lower(privilege)||'('||column_name||<br>     ') ON '||owner||'.'||table_name||&amp;&amp;cr||<br>     ' TO '|| lower(grantee) ||&amp;&amp;cr||<br>     decode(grantable,'YES',' WITH ADMIN OPTION;',';')<br> FROM<br>     sys.dba_col_privs<br> WHERE<br>     grantee NOT IN ('SYS','CONNECT','RESOURCE','DBA',<br>       'EXP_FULL_DATABASE','IMP_FULL_DATABASE')<br> ORDER BY grantor, grantee<br>/<br>SPOOL OFF<br>SET VERIFY ON FEEDBACK ON TERMOUT ON PAGESIZE 22 EMBEDDED OFF<br>CLEAR COLUMNS<br>CLEAR COMPUTES<br>CLEAR BREAKS<br>
<i>Quellcode 11.11: Skript für die Aufzeichnung von Zugriffsrechten auf der Ebene von Tabellenspalten</i><br>
<hr>
<A name=89></a>rem PURPOSE    : Produce report of db policies<br>rem              used to implement row level grants<br>rem<br>rem LIMITATIONS: User must have access to DBA_POLICIES<br>rem<br>rem HISTORY:<br>rem Who:         What:                 Date:<br>rem Mike Ault    Initial creation      5/23/99<br>rem Mike Ault    Updated to Oracle9i   10/13/01<br>rem<br>COLUMN object_owner  FORMAT A10  HEADING 'Object|Owner'<br>COLUMN object_name   FORMAT A19  HEADING 'Object|Name'<br>COLUMN policy_group  FORMAT A12  HEADING 'Policy|Group'<br>COLUMN policy_name   FORMAT A16  HEADING 'Policy|Name'<br>COLUMN pf_owner      FORMAT A10  HEADING 'Policy|Function|Owner'<br>COLUMN function      FORMAT A15  HEADING 'Function|Name'<br>COLUMN sel           FORMAT A3   HEADING 'Sel|?'<br>COLUMN ins           FORMAT A3   HEADING 'Ins|?'<br>COLUMN upd           FORMAT A3   HEADING 'Upd|?'<br>COLUMN del           FORMAT A3   HEADING 'Del|?'<br>COLUMN chk_option    FORMAT A3   HEADING 'Check|Option'<br>COLUMN enable        FORMAT A3   HEADING 'Enabled?'<br>COLUMN static_policy FORMAT A7   HEADING 'Static?'<br>SET LINES 132 VERIFY OFF FEEDBACK OFF PAGES 47<br>START title132 'DB Policies Report'<br>BREAK ON object_owner<br>SPOOL rep_out\&amp;db\db_policies<br>SELECT<br>     object_owner, object_name,policy_group,<br>     policy_name,pf_owner,function,<br>     sel,ins,upd,del,chk_option,<br>     enable,static_policy<br> FROM<br>     dba_policies<br> ORDER BY<br>     1,2,3;<br>SPOOL OFF<br>SET LINES 80 VERIFY ON FEEDBACK ON PAGES 22<br>CLEAR BREAKS<br>CLEAR COLUMNS<br>TTITLE OFF<br>
<i>Quellcode 11.12: Berichtsskript zur Überwachung von Sicherheitsrichtlinien auf Zeilenebene</i><br>
<hr>
<A name=90></a>REM<br>REM  Name     : pid.sql<br>REM<br>REM  FUNCTION : Generate a list of current oracle sids/pids<br>REM<br>COLUMN terminal FORMAT a10   HEADING 'Terminal'<br>COLUMN program  FORMAT a30   HEADING 'Program'<br>COLUMN pid      FORMAT 9999  HEADING 'Process|ID'<br>COLUMN sid      FORMAT 9999  HEADING 'Session|ID'<br>COLUMN osuser   FORMAT A15   HEADING 'Operating|System|User'<br>COLUMN spid     FORMAT A7    HEADING 'OS|Process|ID'<br>COLUMN serial#  FORMAT 99999 HEADING 'Serial|Number'<br>SET LINES 132 PAGES 58<br>BREAK ON username<br>COMPUTE COUNT OF pid ON username<br>START title132 &quot;Oracle Processes&quot;<br>SPOOL rep_out\&amp;db\cur_proc<br>SELECT<br>     NVL(a.username,'Null') username,<br>     b.pid,a.sid,<br>     DECODE(a.terminal,'?','Detached',a.terminal) terminal,<br>     b.program,b.spid,a.osuser,a.serial#<br> FROM<br>     v$session a,<br>     v$process b<br> WHERE<br>     a.PADDR = b.ADDR<br> ORDER by<br>     a.username,<br>     b.pid<br>/<br>SPOOL OFF<br>CLEAR BREAKS<br>CLEAR COLUMNS<br>SET PAGES 22<br>TTITLE OFF<br>PAUSE Press Enter to continue<br>
<i>Quellcode 11.13: Berichtsskript zur Anzeige der aktiven Benutzer</i><br>
rem<br>rem Name     : free_space.sql<br>rem<br>rem FUNCTION : Provide data on tablespace extent status<br>rem FUNCTION : this report uses the free_space2 view<br>rem FUNCTION : includes fsfi from DBA Handbook<br>rem<br>SET FEED OFF<br>SET FLUSH OFF<br>SET VERIFY OFF<br>set pages 58 LINES 132<br>COLUMN tablespace    HEADING Name            FORMAT a30<br>COLUMN files         HEADING '#Files'        FORMAT 9,999<br>COLUMN pieces        HEADING 'Frag'          FORMAT 9,999<br>COLUMN free_bytes    HEADING 'Free|Byte'     FORMAT 9,999,999,999<br>COLUMN free_blocks   HEADING 'Free|Blk'      FORMAT 999,999<br>COLUMN largest_bytes HEADING 'Biggest|Bytes' FORMAT 9,999,999,999<br>COLUMN largest_blks  HEADING 'Biggest|Blks'  FORMAT 999,999<br>COLUMN ratio         HEADING 'Percent'       FORMAT 999.999<br>COLUMN average_fsfi  HEADING 'Average|FSFI'  FORMAT 999.999<br>START title132 &quot;FREE SPACE REPORT&quot;<br>DEFINE 1 = report_output/&amp;&amp;db/free_spc<br>SPOOL &amp;1<br>SELECT<br>
<hr>
<A name=91></a>     tablespace,<br>     COUNT(*) files,<br>     SUM(pieces) pieces,<br>     SUM(free_bytes) free_bytes,<br>     SUM(free_blocks) free_blocks,<br>     SUM(largest_bytes) largest_bytes,<br>     SUM(largest_blks) largest_blks,<br>     SUM(largest_bytes)/sum(free_bytes)*100 ratio,<br>     SUM(fsfi)/COUNT(*) average_fsfi<br> FROM<br>     free_space<br> GROUP BY<br>     tablespace;<br>SPOOL OFF<br>CLEAR COLUMNS<br>TTITLE OFF<br>SET FEED ON<br>SET FLUSH ON<br>SET VERIFY ON<br>SET PAGES 22 LINES 80<br>PAUSE Press Enter to continue<br>
<i>Quellcode 11.14: Berichtsskript für die Nutzung und Fragmentierung von Tablespaces</i><br>
rem<br>rem Name     : free_space_view.sql<br>rem<br>rem FUNCTION : Create free_space view for use by freespc reports<br>rem<br>CREATE VIEW free_space<br>(tablespace, file_id, pieces, free_bytes, free_blocks,<br>largest_bytes,largest_blks, fsfi) AS<br>SELECT tablespace_name, file_id, COUNT(*),<br>     SUM(bytes), SUM(blocks),<br>     MAX(bytes), MAX(blocks),<br>     SQRT(MAX(blocks)/SUM(blocks))*(100/SQRT(SQRT(COUNT(blocks))))<br>FROM sys.dba_free_space<br>GROUP BY tablespace_name, file_id, relative_fno;<br>
<i>Quellcode 11.15: Berichtsskript der Sicht für freien Speicherplatz</i><br>
<hr>
<A name=92></a>CREATE VIEW dba_file_data AS<br>SELECT<br>     a.name tablespace,a.dflminext min_extents,<br>     a.dflmaxext max_extents,<br>     a.dflinit init,a.dflincr next,<br>     a.dflextpct pct_increase, d.name datafile,<br>     b.blocks datafile_size, c.maxextend max_extend,<br>     c.inc ext_incr<br> FROM<br>     ts$ a, file$ b, filext$ c, v$dbfile d<br> WHERE<br>     a.ts#=b.ts# and b.file#=c.file# and b.file#=d.file#<br>/<br>
<i>Quellcode 11.16: Skript zum Erstellen einer Sicht für Datendateien</i><br>
<hr>
<A name=93></a>REM<br>REM  Name     : dbfiles.sql<br>REM  FUNCTION : Document file sizes and locations<br>REM  Use      : From SQLPLUS<br>REM  MRA 05/16/99 Added autoextend monitoring<br>REM  MRA 10/14/99 Added temp file monitoring 9i<br>REM<br>CLEAR COMPUTES<br>COLUMN file_name       FORMAT A51       HEADING 'File Name'<br>COLUMN tablespace_name FORMAT A15       HEADING 'Tablespace'<br>COLUMN meg             FORMAT 99,999.90 HEADING 'Megabytes'<br>COLUMN status          FORMAT A10       HEADING 'Status'<br>COLUMN autoextensible  FORMAT A3        HEADING 'AE?'<br>COLUMN maxmeg          FORMAT 99,999    HEADING 'Max|Megabytes'<br>COLUMN Increment_by    FORMAT 9,999     HEADING 'Inc|By'<br>SET LINES 130 PAGES 47 VERIFY OFF FEEDBACK OFF<br>START title132 'DATABASE DATA FILES'<br>SPOOL rep_out\&amp;db\datafile<br>BREAK ON tablespace_name SKIP 1 ON REPORT<br>COMPUTE SUM OF meg ON tablespace_name<br>COMPUTE SUM OF meg ON REPORT<br>SELECT<br>     tablespace_name,file_name,<br>     bytes/1048576 meg,<br>     status,autoextensible,<br>     maxbytes/1048576 maxmeg,<br>     increment_by<br> FROM<br>     dba_data_files<br>UNION<br>SELECT<br>     tablespace_name,file_name,<br>     bytes/1048576 meg,<br>     status,autoextensible,<br>     maxbytes/1048576 maxmeg,<br>     increment_by<br> FROM<br>     dba_temp_files<br> ORDER BY<br>     tablespace_name<br>/<br>SPOOL OFF<br>SET VERIFY ON FEEDBACK ON<br>TTITLE OFF<br>CLEAR COLUMNS<br>CLEAR COMPUTES<br>PAUSE Press Enter to continue<br>
<i>Quellcode 11.17: Skript zur Dokumentation von Datendateien für Tablespaces</i><br>
<hr>
<A name=94></a>rem<br>rem Name     : mapper.sql<br>rem Function : create an extent map for a specific tablespace<br>rem            Based on a technique from DBA Handbook<br>rem Mike Ault 7/19/96 TUSC<br>rem<br>SET PAGES 47 LINES 132 VERIFY OFF FEEDBACK OFF<br>COLUMN file_id                        HEADING 'File|id'<br>COLUMN value          NEW_VALUE dbblksiz NOPRINT<br>COLUMN meg            FORMAT 9,999.99 HEADING 'Meg'<br>COLUMN partition_name FORMAT a30      HEADING 'Partition|Name'<br>SELECT value FROM v$parameter WHERE name='db_block_size';<br>START title132 '&amp;&amp;ts Mapping Report'<br>SPOOL rep_out/&amp;db/ts_map<br>SELECT<br>     'free space' owner, '      ' object,'Not Part.' partition<br>     file_id, block_id, blocks,<br>     (blocks*&amp;dbblksiz)/(1024*1024) meg<br> FROM<br>     dba_free_space<br> WHERE<br>     tablespace_name=UPPER('&amp;&amp;ts')<br>UNION<br>SELECT<br>     SUBSTR(owner,1,20), SUBSTR(segment_name, 1,32),partition_name<br>     file_id, block_id, blocks,<br>     (blocks*&amp;dbblksiz)/(1024*1024) meg<br> FROM<br>     dba_extents<br> WHERE<br>     tablespace_name = UPPER('&amp;&amp;ts')<br> ORDER BY 3,4;<br>SPOOL OFF<br>UNDEF ts<br>SET PAGES 22 LINES 80 VERIFY ON FEEDBACK ON<br>CLEAR COLUMNS<br>TTITLE OFF<br>
<i>Quellcode 11.18: Skript zur Dokumentation des freien Platzes in den Extents eines Tablespaces</i><br>
<hr>
<A name=95></a>rem NAME    : Seq_rep.sql<br>rem<br>rem HISTORY :<br>rem Date      Who                      What<br>rem --------  ----------------------   --------------<br>rem 5/10/93   Mike Ault                Creation<br>rem 5/16/99   Mike Ault                Verified for Oracle8i<br>rem FUNCTION: Generate report on Sequences<br>rem INPUTS  :<br>rem           1 - Sequence Owner or Wild Card<br>rem           2 - Sequence Name or Wild Card<br>rem<br>rem **************************************************************<br>SET HEADING OFF VERIFY OFF PAUSE OFF<br>PROMPT ** Sequence Report **<br>PROMPT<br>PROMPT Percent signs are wild<br>ACCEPT sequence_owner char PROMPT 'Enter account to report on (or pct<br>sign):';<br>ACCEPT sequence_name char PROMPT 'Enter sequence to report on (or pct<br>sign):';<br>PROMPT<br>PROMPT Report file name is SEQUENCE.LIS<br>SET HEADING ON<br>SET LINESIZE 80 PAGESIZE 56 NEWPAGE 0 TAB OFF SPACE 1<br>SET TERMOUT OFF VERIFY OFF FEEDBACK OFF<br>BREAK ON sequence_owner SKIP 2<br>COLUMN sequence_owner  FORMAT A10    HEADING 'Sequence|Owner'<br>COLUMN sequence_name   FORMAT A16    HEADING 'Sequence|Name'<br>COLUMN min_value                     HEADING 'Minimum'<br>COLUMN max_value                     HEADING 'Maximum'<br>COLUMN increment_by    FORMAT 999    HEADING 'Inc'<br>COLUMN cycle_flag                    HEADING 'Cycle'<br>COLUMN order_flag                    HEADING 'Order'<br>COLUMN cache_size      FORMAT 99999  HEADING 'Cache'<br>COLUMN last_number     FORMAT 99999  HEADING 'Last|Value'<br>START title80 &quot;SEQUENCE REPORT&quot;<br>SPOOL rep_out/&amp;&amp;db/seq_rep<br>SELECT<br>     sequence_owner,sequence_name,<br>     min_value,max_value,<br>     increment_by,<br>     DECODE(cycle_flag,'Y','YES','N','NO') cycle_flag,<br>     DECODE(order_flag,'Y','YES','N','NO') order_flag,<br>     cache_size,last_number<br> FROM<br>     dba_sequences<br> WHERE<br>     sequence_owner LIKE UPPER('&amp;sequence_owner') AND<br>     sequence_name LIKE UPPER('&amp;sequence_name')<br> ORDER BY<br>     1,2;<br>SPOOL OFF<br>SET LINESIZE 80 PAGESIZE 22 NEWPAGE 0 TAB ON SPACE 1<br>SET TERMOUT ON VERIFY ON FEEDBACK ON<br>CLEAR BREAKS<br>CLEAR COLUMNS<br>TTITLE OFF<br>
<i>Quellcode 11.19: Berichtsskript für Sequenzen</i><br>
<hr>
<A name=96></a>REM<br>REM NAME        : SYNONYM.SQL<br>REM PURPOSE     : GENERATE REPORT OF A USERS SYNONYMS<br>REM USE         : FROM SQLPLUS<br>REM Limitations : None<br>REM Revisions   :<br>REM Date          Modified by       Reason for change<br>REM 12/MAY/93     Mike Ault         Initial Creation<br>REM 15/Jun/97     Mike Ault         Verified for Oracle8<br>REM 16/May/99     Mike Ault         Verified for Oracle8i<br>REM<br>PROMPT Percent signs are Wild Cards<br>PROMPT<br>ACCEPT own PROMPT 'Enter the user who owns synonym: '<br>SET PAGES 56 LINES 130 VERIFY OFF FEEDBACK OFF TERM OFF<br>START title132 &quot;Synonym Report&quot;<br>SPOOL rep_out/&amp;&amp;db/synonym<br>COLUMN host      FORMAT a24  HEADING &quot;Connect String&quot;<br>COLUMN owner     FORMAT a15<br>COLUMN table     FORMAT a35<br>COLUMN db_link   FORMAT a6   HEADING Link<br>COLUMN username  FORMAT a15<br>SELECT<br>     a.owner, synonym_name ,<br>     table_owner ||'.'|| table_name &quot;Table&quot; ,<br>     b.db_link,username,host<br> FROM<br>     dba_synonyms a,<br>     dba_db_links b<br> WHERE<br>     a.db_link = b.db_link(+) AND<br>     a.owner LIKE UPPER('&amp;own');<br>SPOOL OFF<br>SET PAGES 22 LINES 80 VERIFY ON FEEDBACK ON TERM ON<br>CLEAR COLUMNS<br>CLEAR BREAKS<br>TTITLE OFF<br>
<i>Quellcode 11.20: Berichtsskript für Synonyme</i><br>
<hr>
<A name=97></a>REM<br>REM NAME        : DBLINK_REP.SQL<br>REM FUNCTION    : GENERATE REPORT OF DATABASE LINKS<br>REM USE         : FROM SQLPLUS<br>REM Limitations : None<br>REM MRA 10/14/01  Verified for Oracle9i<br>REM<br>SET PAGES 58 LINES 80 VERIFY OFF TERM OFF<br>START title80 &quot;Db Links Report&quot;<br>SPOOL rep_out/&amp;db/dblink_rep<br>COLUMN host      FORMAT a18  HEADING &quot;Connect|String&quot;<br>COLUMN owner     FORMAT a8   HEADING &quot;Creator&quot;<br>COLUMN db_link   FORMAT a19  HEADING &quot;DB Link|Name&quot;<br>COLUMN username  FORMAT a8   HEADING &quot;Connect|User&quot;<br>COLUMN created   FORMAT a15  HEADING &quot;Date|Created&quot;<br>SELECT<br>     host,owner,db_link,username,<br>     to_char(created,'dd-mon-yy hh24:mi') created<br> FROM<br>     dba_db_links<br> ORDER BY<br>     owner,<br>     host;<br>SPOOL OFF<br>SET PAGES 22 LINES 80 VERIFY ON FEEDBACK ON TERM ON<br>CLEAR COLUMNS<br>TTITLE OFF<br>PAUSE Press Enter to continue<br>
<i>Quellcode 11.21: Berichtsskript für Datenbanklinks</i><br>
<hr>
<A name=98></a>REM<br>REM FUNCTION: create views required for rbk1 and rbk2 reports.<br>REM<br>REM<br>CREATE OR REPLACE VIEW rollback1 AS<br>SELECT<br>     d.segment_name, extents, optsize, shrinks,<br>     aveshrink, aveactive, d.status<br> FROM<br>     v$rollname n,<br>     v$rollstat s,<br>     dba_rollback_segs d<br> WHERE<br>     d.segment_id=n.usn(+)<br>     AND d.segment_id=s.usn(+)<br>;<br>CREATE OR REPLACE VIEW rollback2 AS<br>SELECT<br>     d.segment_name,extents,xacts,hwmsize,<br>     rssize,waits,wraps,extends,d.status<br> FROM<br>     v$rollname n,<br>     v$rollstat s,<br>     dba_rollback_segs d<br> WHERE<br>     d.segment_id=n.usn(+)<br>     AND d.segment_id=s.usn(+)<br>;<br>
<i>Quellcode 11.22: SQL-Skripten zum Generieren der Sichten </i>ROLLBACK1<i> und </i>ROLLBACK2<br>
<hr>
<A name=99></a>REM NAME        : RBK1.SQL<br>REM FUNCTION    : REPORT ON ROLLBACK SEGMENT STORAGE<br>REM FUNCTION    : USES THE ROLLBACK1 VIEW<br>REM USE         : FROM SQLPLUS<br>REM Limitations : None<br>REM<br>COLUMN hwmsize         FORMAT 9999999999 HEADING 'LARGEST TRANS'<br>COLUMN tablespace_name FORMAT a10        HEADING 'TABLESPACE'<br>COLUMN segment_name    FORMAT A10        HEADING 'ROLLBACK'<br>COLUMN optsize         FORMAT 9999999999 HEADING 'OPTL|SIZE'<br>COLUMN shrinks         FORMAT 9999       HEADING 'SHRINKS'<br>COLUMN aveshrink       FORMAT 9999999999 HEADING 'AVE|SHRINK'<br>COLUMN aveactive       FORMAT 9999999999 HEADING 'AVE|TRANS'<br>COLUMN waits           FORMAT 99999      HEADING 'WAITS'<br>COLUMN wraps           FORMAT 99999      HEADING 'WRAPS'<br>COLUMN extends         FORMAT 9999       HEADING 'EXTENDS'<br>rem<br>BREAK ON REPORT<br>COMPUTE AVG OF AVESHRINK ON REPORT<br>COMPUTE AVG OF AVEACTIVE ON REPORT<br>COMPUTE AVG OF SHRINKS ON REPORT<br>COMPUTE AVG OF WAITS ON REPORT<br>COMPUTE AVG OF WRAPS ON REPORT<br>COMPUTE AVG OF EXTENDS ON REPORT<br>COMPUTE AVG OF HWMSIZE ON REPORT<br>SET FEEDBACK OFF VERIFY OFF LINES 132 PAGES 58<br>@title132 &quot;ROLLBACK SEGMENT STORAGE&quot;<br>SPOOL rep_out\&amp;db\rbk1<br>rem<br>SELECT<br>     a.SEGMENT_NAME,a.OPTSIZE,a.SHRINKS,<br>     a.AVESHRINK,a.AVEACTIVE,b.HWMSIZE,<br>     b.WAITS,b.WRAPS,b.EXTENDS,A.STATUS<br> FROM rollback1 a, rollback2 b<br> WHERE A.SEGMENT_NAME=B.SEGMENT_NAME<br> ORDER BY segment_name;<br>SPOOL OFF<br>CLEAR COLUMNS<br>TTITLE OFF<br>SET FEEDBACK ON VERIFY ON LINES 80 PAGES 22<br>PAUSE Press enter to continue<br>
REM<br>REM NAME        : RBK2.SQL<br>REM FUNCTION    : REPORT ON ROLLBACK SEGMENT STATISTICS<br>REM FUNCTION    : USES THE ROLLBACK2 VIEW<br>REM USE         : FROM SQLPLUS<br>REM Limitations : None<br>REM<br>COLUMN segment_name FORMAT A8         HEADING 'ROLLBACK'<br>COLUMN extents      FORMAT 99999      HEADING 'EXTENTS'<br>COLUMN xacts        FORMAT 9999       HEADING 'TRANS'<br>COLUMN hwmsize      FORMAT 9999999999 HEADING 'LARGEST TRANS'<br>COLUMN rssize       FORMAT 9999999999 HEADING 'CUR SIZE'<br>COLUMN waits        FORMAT 99999      HEADING 'WAITS'<br>COLUMN wraps        FORMAT 99999      HEADING 'WRAPS'<br>COLUMN extends      FORMAT 9999       HEADING 'EXTENDS'<br>rem<br>SET FEEDBACK OFF VERIFY OFF lines 132 pages 58<br>BREAK ON REPORT<br>COMPUTE AVG OF WAITS ON REPORT<br>COMPUTE AVG OF WRAPS ON REPORT<br>COMPUTE AVG OF EXTENDS ON REPORT<br>COMPUTE AVG OF HWMSIZE ON REPORT<br>rem<br>
<hr>
<A name=100></a>@title132 &quot;ROLLBACK SEGMENT STATISTICS&quot;<br>SPOOL rep_out\&amp;db\rbk2<br>rem<br>SELECT * FROM rollback2 ORDER BY segment_name;<br>SPOOL OFF<br>SET LINES 80 PAGES 20 FEEDBACK ON VERIFY ON<br>TTITLE OFF<br>CLEAR COLUMNS<br>PAUSE Press enter to continue<br>
REM<br>REM NAME        : RBK3.SQL<br>REM FUNCTION    : REPORT ON ROLLBACK SEGMENT HEALTH<br>REM FUNCTION    : USES THE ROLLBACK1 and ROLLBACK2 VIEWs<br>REM USE         : FROM SQLPLUS<br>REM Limitations : None<br>REM<br>COLUMN hwmsize         FORMAT 9999999999 HEADING 'LARGEST TRANS'<br>COLUMN tablespace_name FORMAT a10        HEADING 'TABLESPACE'<br>COLUMN segment_name    FORMAT A10        HEADING 'ROLLBACK'<br>COLUMN optsize         FORMAT 9999999999 HEADING 'OPTL|SIZE'<br>COLUMN shrinks         FORMAT 9999       HEADING 'SHRINKS'<br>COLUMN aveshrink       FORMAT 9999999999 HEADING 'AVE|SHRINK'<br>COLUMN aveactive       FORMAT 9999999999 HEADING 'AVE|TRANS'<br>COLUMN waits           FORMAT 99999      HEADING 'WAITS'<br>COLUMN wraps           FORMAT 99999      HEADING 'WRAPS'<br>COLUMN extends         FORMAT 9999       HEADING 'EXTENDS'<br>rem<br>BREAK ON REPORT<br>COMPUTE AVG OF AVESHRINK ON REPORT<br>COMPUTE AVG OF AVEACTIVE ON REPORT<br>COMPUTE AVG OF SHRINKS ON REPORT<br>COMPUTE AVG OF WAITS ON REPORT<br>COMPUTE AVG OF WRAPS ON REPORT<br>COMPUTE AVG OF EXTENDS ON REPORT<br>COMPUTE AVG OF HWMSIZE ON REPORT<br>SET FEEDBACK OFF VERIFY OFF LINES 132 PAGES 47<br>@title132 &quot;ROLLBACK SEGMENT HEALTH&quot;<br>SPOOL rep_out\&amp;db\rbk3<br>rem<br>SELECT c.tablespace_name, a.segment_name, a.optsize, a.shrinks,<br>     a.aveshrink,a.aveactive,<br>     b.hwmsize, b.waits, b.wraps, b.extends<br> FROM rollback1 a, rollback2 b, dba_rollback_segs c<br> WHERE a.segment_name=b.segment_name<br>     and c.segment_name=a.segment_name<br> ORDER BY tablespace_name, segment_name;<br>SPOOL OFF<br>CLEAR COLUMNS<br>TTITLE OFF<br>SET FEEDBACK ON VERIFY ON LINES 80 PAGES 22<br>PAUSE Press enter to continue<br>
<i>Quellcode 11.23: Skripten zum Erstellen eines Berichts für Rollbacksegmente</i><br>
<hr>
<A name=101></a>REM undo_usage.sql<br>REM Function: reports undo usage for Oracle9i<br>REM<br>REM MRA 10/14/01 Initial Creation<br>REM<br>COLUMN undo_usage       FORMAT 99,999,999.999 HEADING 'Undo Usage|Blocks/Min'<br>COLUMN oer_old_errors   FORMAT 99,999,999     HEADING 'Undo|Old Errors'<br>COLUMN oer_space_errors FORMAT 9,999,999,999  HEADING 'Undo|Space Errors'<br>SET FEEDBACK OFF<br>@title80 'Undo Usage'<br>spool rep_out/&amp;db/undo_usage<br>SELECT<br>     sum(undoblks)/sum((end_time-begin_time)*24*60) undo_usage,<br>     sum(ssolderrcnt) OER_old_errors,<br>     sum(nospaceerrcnt) OER_space_errors<br> FROM<br>     v$undostat<br> WHERE<br>     undoblks&gt;0<br>/<br>spool off<br>SET FEEDBACK ON<br>TTITLE OFF<br>
<i>Quellcode 11.24: Berichtsskript für die Undo-Auslastung</i><br>
<hr>
<A name=102></a>rem Name    : TX_RBS.SQL<br>rem Purpose : Generate a report of active rollbacks<br>rem Use     : From SQL*Plus<br>rem History :<br>rem Date      Who             What<br>rem Sept 91   Lan Nguyen      Presented in paper at IOUG<br>rem           Walter Lindsey<br>rem 5/15/93   Mike Ault       Added Title80, sets and output<br>rem 1/04/97   Mike Ault       Verified against 7.3<br>rem 5/16/99   Mike Ault       Verified against Oracle8i<br>rem 10/14/01  Mike Ault       Verified against Oracle9i<br>rem                           reformated added curext, curblk<br>rem**********************************************************<br>COLUMN name        FORMAT a10    HEADING &quot;Rollback|Segment&quot;<br>COLUMN pid         FORMAT 99999  HEADING &quot;Oracle|PID&quot;<br>COLUMN spid        FORMAT 99999  HEADING &quot;Sys|PID&quot;<br>COLUMN curext      FORMAT 999999 HEADING &quot;Current|Extent&quot;<br>COLUMN curblk      FORMAT 999999 HEADING &quot;Current|Block&quot;<br>COLUMN transaction FORMAT A15    Heading 'Transaction'<br>COLUMN program     FORMAT a10    HEADING 'Program'<br>SET PAGES 56 LINES 80 VERIFY OFF FEEDBACK OFF<br>START title80 &quot;Rollback Segments in Use&quot;<br>SPOOL rep_out\&amp;db\tx_rbs<br>SELECT<br>     r.name, l.Sid, p.spid,<br>     NVL(p.username, 'no transaction') &quot;Transaction",<br>     p.program &quot;Program",<br>     s.curext,s.curblk<br> FROM<br>     v$lock l,<br>     v$process p,<br>     v$rollname r,<br>     v$rollstat s<br> WHERE<br>         l.Sid = p.pid (+)<br>     AND TRUNC(l.id1(+) / 65536) = r.usn<br>     AND l.type(+) = 'TX'<br>     AND l.lmode(+) = 6<br>     AND r.usn=s.usn<br>     AND p.username is not null<br> ORDER BY r.name;<br>SPOOL OFF<br>SET PAGES 22 LINES 80 VERIFY ON FEEDBACK ON<br>CLEAR COLUMNS<br>TTITLE OFF<br>
<i>Quellcode 11.25: Berichtsskript für aktive Rollbacks</i><br>
<hr>
<A name=103></a>rem**********************************************************<br>rem Name        : UNDO.SQL<br>rem Purpose     : Document rollback usage for a single<br>rem               transaction<br>rem Use         : Note: You must alter the UNDO script and add a<br>rem               call to the transaction at the indicated line<br>rem Restrictions: The database should be placed in DBA mode<br>rem               and this transaction should be the only one<br>rem               running.<br>rem History     :<br>rem  Date         Who              What<br>rem  Sept 91      Lan Nguyen       Presented in paper at IOUG<br>rem              Walter Lindsey<br>rem  5/15/93      Mike Ault        Changed to use one table<br>rem<br>SET FEEDBACK OFF TERMOUT OFF<br>COLUMN name FORMAT a40<br>DEFINE undo_overhead=54<br>DROP TABLE undo_data;<br>CREATE TABLE undo_data<br>     (<br>     tran_no number, start_writes number, end_writes number<br>     );<br>INSERT INTO undo_data<br>SELECT 1, SUM(writes),0 from v$rollstat;<br>SET FEEDBACK ON TERMOUT ON<br>rem<br>rem    !!! INSERT TRANSACTION HERE !!!<br>rem<br>SET FEEDBACK OFF TERMOUT OFF<br>UPDATE undo_data SET end_writes = SUM(writes) FROM v$rollstat;<br> WHERE tran_no=1;<br>SET FEEDBACK ON TERMOUT ON<br>SELECT ((end-writes - start_writes) - &amp;undo_overhead)<br>     &quot;Number of Rollback Bytes Generated&quot;<br> FROM undo_data;<br>SET TERMOUT OFF FEEDBACK OFF<br>DROP TABLE undo_data;<br>
<i>Quellcode 11.26: Skript zur Ermittlung der Byteanzahl beim Rollback einer Transaktion</i><br>
<hr>
<A name=104></a>rem<br>rem Name     : log_stat.sql<br>rem<br>rem FUNCTION : Provide a current status for redo logs<br>rem<br>rem<br>COLUMN first_change# FORMAT 99999999 HEADING Change#<br>COLUMN group#        FORMAT 9,999    HEADING Grp#<br>COLUMN thread#       FORMAT 999      HEADING Th#<br>COLUMN sequence#     FORMAT 999,999  HEADING Seq#<br>COLUMN members       FORMAT 999      HEADING Mem<br>COLUMN archived      FORMAT a4       HEADING Arc?<br>COLUMN first_time    FORMAT a21      HEADING 'Switch|Time'<br>BREAK ON thread#<br>SET PAGES 60 LINES 131 FEEDBACK OFF<br>START title132 'Current Redo Log Status'<br>SPOOL rep_out\&amp;db\log_stat<br>SELECT thread#,group#,sequence#,bytes,<br>     members,archived,<br>     status,first_change#,<br>     TO_CHAR(first_time, 'DD-MM-YYYY HH24:MI:SS') first_time<br> FROM<br>     sys.v_$log<br> ORDER BY<br>     thread#,<br>     group#;<br>SPOOL OFF<br>PAUSE Press Enter to continue<br>SET PAGES 22 LINES 80 FEEDBACK ON<br>CLEAR BREAKS<br>CLEAR COLUMNS<br>TTILE OFF<br>
<i>Quellcode 11.27: Beispielskript </i>log_stat.sql<br>
<hr>
<A name=105></a>REM<br>REM NAME        :log_hist.sql<br>REM PURPOSE     :Provide info on logs for last 24 hours since last<br>REM PURPOSE     :log switch<br>REM USE         : From SQLPLUS<br>REM Limitations : None<br>REM MRA 10/14/01 Updated for Oracle9i<br>REM<br>COLUMN thread#        FORMAT 999    HEADING 'Thrd#'<br>COLUMN sequence#      FORMAT 99999  HEADING 'Seq#'<br>COLUMN first_change#                HEADING 'SCN Low#'<br>COLUMN next_change#                 HEADING 'SCN High#'<br>COLUMN archive_name   FORMAT a50    HEADING 'Log File'<br>COLUMN first_time     FORMAT a20    HEADING 'Switch Time'<br>COLUMN name           FORMAT a30    HEADING 'Archive Log'<br>SET LINES 132 FEEDBACK OFF VERIFY OFF<br>START title132 &quot;Log History Report&quot;<br>SPOOL rep_out\&amp;db\log_hist<br>REM<br>SELECT<br>     X.recid,a.thread#,<br>     a.sequence#,a.first_change#,<br>     a.switch_change#,<br>     TO_CHAR(a.first_time,'DD-MON-YYYY HH24:MI:SS') first_time,<br>     x.name<br> FROM<br>     v$loghist a, v$archived_log x<br> WHERE<br>     a.first_time&gt;<br>     (SELECT b.first_time-1<br>      FROM v$loghist b WHERE b.switch_change# =<br>         (SELECT MAX(c.switch_change#) FROM v$loghist c)) AND<br>         x.recid(+)=a.sequence#;<br>SPOOL OFF<br>SET LINES 80 VERIFY ON FEEDBACK ON<br>CLEAR COLUMNS<br>TTITLE OFF<br>PAUSE Press Enter to continue<br>
<i>Quellcode 11.28: Skript zur Überwachung der Wechsel von Redo-Logs</i><br>
<hr>
<A name=106></a>REM<br>REM NAME        : rdo_stat.sql<br>REM PURPOSE     : Show REDO latch statistics<br>REM USE         : from SQLPlus<br>REM Limitations : Must have access to v$_ views<br>REM<br>SET PAGES 56 LINES 78 VERIFY OFF FEEDBACK OFF<br>START title80 &quot;Redo Latch Statistics&quot;<br>SPOOL rep_out/&amp;&amp;db/rdo_stat<br>rem<br>COLUMN name     FORMAT a30      HEADING Name<br>COLUMN percent  FORMAT 999.999  HEADING Percent<br>COLUMN total                    HEADING Total<br>rem<br>SELECT<br>     l2.name,<br>     immediate_gets+gets Total,<br>     immediate_gets &quot;Immediates",<br>     misses+immediate_misses &quot;Total Misses",<br>     DECODE (100.*(GREATEST(misses+immediate_misses,1)/<br>     GREATEST(immediate_gets+gets,1)),100,0) Percent<br> FROM<br>     v$latch l1,<br>     v$latchname l2<br> WHERE<br>     l2.name like '%redo%'<br>     and l1.latch#=l2.latch# ;<br>rem<br>PAUSE Press Enter to continue<br>
rem<br>rem Name     : Redo_stat.sql<br>rem<br>rem Function : Select redo statistics from v$sysstat<br>rem History  :<br>rem Who        What               Date<br>rem ---------  ----------------   -------<br>rem Mike Ault  Revised from V6    1/04/97<br>rem Mike Ault  Verified Oracle8   6/15/97<br>rem<br>COLUMN name   FORMAT a30          HEADING 'Redo|Statistic|Name'<br>COLUMN value  FORMAT 999,999,999  HEADING 'Redo|Statistic|Value'<br>SET PAGES 80 LINES 60 FEEDBACK OFF VERIFY OFF<br>START title80 'Redo Log Statistics'<br>SPOOL rep_out/&amp;&amp;db/redo_stat<br>SELECT<br>     name,<br>     value<br> FROM<br>     v$sysstat<br> WHERE<br>     name LIKE '%redo%'<br> ORDER BY statistic#;<br>SPOOL OFF<br>SET LINES 24 FEEDBACK ON VERIFY ON<br>TTITLE OFF<br>CLEAR COLUMNS<br>CLEAR BREAKS<br>
<i>Quellcode 11.29: Berichtsskript für statistische Werte zum Redo</i><br>
<hr>
<A name=107></a>rem NAME     : dir_rep.sql<br>rem FUNCTION : Report on directories known by the database<br>rem HISTORY  : MRA 6/16/97   Created for Oracle8<br>rem            MRA 5/16/99   Verified for Oracle8i<br>rem            MRA 10/14/01  Verified for Oracle9i<br>rem<br>COLUMN owner            FORMAT a10  HEADING 'Owner'<br>COLUMN directory_name   FORMAT a15  HEADING 'Directory'<br>COLUMN directory_path   FORMAT a45  HEADING 'Full Path'<br>SET VERIFY OFF PAGES 58 LINES 78 FEEDBACK OFF<br>START title80 'Database Directories Report'<br>SPOOL rep_out\&amp;db\dir_rep.lis<br>SELECT<br>     owner,directory_name,directory_path<br> FROM<br>     dba_directories<br> ORDER BY<br>     owner;<br>SPOOL OFF<br>SET VERIFY ON FEEDBACK ON<br>TTITLE OFF<br>CLEAR COLUMNS<br>
<i>Quellcode 11.30: Berichtsskript für Datenbankverzeichnisse</i><br>
<hr>
<A name=108></a>rem<br>rem NAME     : lib_rep.sql<br>rem FUNCTION : Document External Library Entries in Database<br>rem HISTORY  : MRA 6/16/97   Created<br>rem            MRA 10/14/01  Updated for Oracle9i<br>rem<br>COLUMN owner         FORMAT a8   HEADING 'Library|Owner'<br>COLUMN library_name  FORMAT a15  HEADING 'Library|Name'<br>COLUMN file_spec     FORMAT a30  HEADING 'File|Specification'<br>COLUMN dynamic       FORMAT a7   HEADING 'Dynamic'<br>COLUMN status        FORMAT a10  HEADING 'Status'<br>BREAK ON owner<br>SET FEEDBACK OFF VERIFY OFF LINES 78 PAGES 58<br>START title80 'Database External Libraries Report'<br>SPOOL rep_out\&amp;db\lib_rep.lis<br>SELECT<br>     owner,library_name,file_spec,dynamic,status<br> FROM<br>     dba_libraries<br> ORDER BY<br>     owner;<br>SPOOL OFF<br>SET VERIFY ON FEEDBACK ON<br>TTITLE OFF<br>CLEAR COLUMNS<br>CLEAR BREAKS<br>
<i>Quellcode 11.31: Berichtsskript zur Dokumentation externen Bibliotheksspezifikationen</i><br>
<hr>
<A name=109></a>rem<br>rem NAME     : con_file.sql<br>rem FUNCTION : Document control file location and status<br>rem HISTORY  : MRA 6/16/97   Creation<br>rem            MRA 10/14/01  Verified against Oracle9i<br>rem<br>COLUMN name    FORMAT a60  HEADING 'Con|File|Location' WORD_WRAPPED<br>COLUMN status  FORMAT a7   HEADING 'Con|File|Status'<br>SET LINES 78 FEEDBACK OFF VERIFY OFF<br>START title80 'Control File Status'<br>SPOOL rep_out\&amp;db\con_file.lis<br>SELECT<br>     name,status<br> FROM<br>     v$controlfile;<br>SPOOL OFF<br>SET VERIFY ON FEEDBACK ON<br>TTITLE OFF<br>CLEAR COLUMNS<br>
<i>Quellcode 11.32: Berichtsskript zur Überwachung von Speicherort und Status für Steuerdateien</i><br>
<hr>
<A name=110></a>rem<br>rem NAME     : con_rec.sql<br>rem FUNCTION : Provide documentation of control file record stats<br>rem HISTORY  : MRA 6/16/97   Creation<br>rem            MRA 10/14/01  Verified for Oracle9i<br>rem<br>COLUMN type          FORMAT a18      HEADING 'Record Type'<br>COLUMN record_size   FORMAT 999999   HEADING 'Record|Size'<br>COLUMN records_used  FORMAT 999999   HEADING 'Records|Used'<br>COLUMN first_index   FORMAT 9999999  HEADING 'First|Index'<br>COLUMN last_index    FORMAT 9999999  HEADING 'Last|Index'<br>COLUMN last_recid    FORMAT 999999   HEADING 'Last|Record|ID'<br>SET LINES 80 PAGES 58 FEEDBACK OFF VERIFY OFF<br>START title80 'Control File Records'<br>SPOOL rep_out\&amp;db\con_rec.lis<br>SELECT<br>     type,record_size,records_total,records_used,first_index,<br>     last_index,last_recid<br> FROM<br>     v$controlfile_record_section;<br>SPOOL OFF<br>CLEAR COLUMNS<br>SET FEEDBACK ON VERIFY ON<br>TTITLE OFF<br>
<i>Quellcode 11.33: Berichtsskript zur Überwachung der Datensätze in Steuerdateien</i><br>
<hr>
<A name=111></a>REM<br>REM NAME        : init_ora_rct.sql<br>REM FUNCTION    : Re-create the instance init.ora file<br>REM USE         : GENERAL<br>REM Limitations : None<br>REM History     : MRA 11/7/95    Initial creation<br>REM               MRA 10/14/01   Updated for Oracle9i<br>REM<br>SET NEWPAGE 0 VERIFY OFF<br>SET ECHO OFF FEEDBACK OFF TERMOUT OFF PAGES 300 LINES 80 HEADING OFF<br>COLUMN name  FORMAT a80 WORD_WRAPPED<br>COLUMN dbname NEW_VALUE db NOPRINT<br>SELECT name dbname FROM v$database;<br>DEFINE OUTPUT = 'rep_out\&amp;db\init.ora'<br>SPOOL &amp;OUTPUT<br>SELECT '# Init.ora file FROM v$system_parameter' name FROM dual<br>UNION<br>SELECT '# generated on:'||sysdate name FROM dual<br>UNION<br>SELECT '# script by MRA 10/14/01 TUSC' name FROM dual<br>UNION<br>SELECT '#' name FROM dual<br>UNION<br>SELECT name||' = '||value name FROM v$system_parameter<br> WHERE value IS NOT NULL and isdefault='FALSE';<br>SPOOL OFF<br>CLEAR COLUMNS<br>SET NEWPAGE 0 VERIFY OFF<br>SET TERMOUT ON PAGES 22 LINES 80 HEADING ON<br>SET TERMOUT ON<br>UNDEF OUTPUT<br>PAUSE Press Enter to continue<br>
<i>Quellcode 11.34: Skript zur Wiederherstellung der Datei </i>init&lt;SID&gt;.ora<br>
<hr>
<A name=112></a>rem NAME     : waiters.sql<br>rem FUNCTION : Report on sessions waiting for locks<br>rem HISTORY  : MRA 1/12/96    Creation<br>rem            MRA 10/14/01   Updated for Oracle9i<br>rem<br>COLUMN busername       FORMAT a10     HEADING 'Holding|User'<br>COLUMN wusername       FORMAT a10     HEADING 'Waiting|User'<br>COLUMN bsession_id                    HEADING 'Holding|SID'<br>COLUMN wsession_id                    HEADING 'Waiting|SID'<br>COLUMN mode_held       FORMAT a10     HEADING 'Mode|Held'<br>COLUMN mode_requested  FORMAT 999999  HEADING 'Mode|Requested'<br>COLUMN lock_id1        FORMAT 999999  HEADING 'Lock|ID1'<br>COLUMN lock_id2        FORMAT a15     HEADING 'Lock|ID2'<br>COLUMN type                           HEADING 'Lock|Type'<br>SET LINES 132 PAGES 59 FEEDBACK OFF ECHO OFF<br>START title132 'Processes Waiting on Locks Report'<br>SPOOL rep_out/&amp;db/waiters<br>SELECT<br>     holding_session bsession_id,<br>     waiting_session wsession_id,<br>     b.username busername,<br>     a.username wusername,<br>     c.lock_type type,<br>     mode_held, mode_requested,<br>     lock_id1, lock_id2<br> FROM<br>     sys.v_$session b,<br>     sys.dba_waiters c,<br>     sys.v_$session a<br> WHERE<br>     c.holding_session=b.sid and<br>     c.waiting_session=a.sid<br>/<br>SPOOL OFF<br>PAUSE press Enter to continue<br>CLEAR COLUMNS<br>SET LINES 80 PAGES 22 FEEDBACK ON<br>TTITLE OFF<br>
<i>Quellcode 11.35: Berichtsskript für Sitzungen, die auf die Freigabe von Sperren warten</i><br>
<hr>
<A name=113></a>rem NAME     : blockers.sql<br>rem FUNCTION : Show all processes causing a dead lock<br>rem HISTORY  : MRA 1/15/96   Created<br>rem            MRA 5/21/99   dba_locks becomes dba_lock in 8.1.5<br>rem            MRA 10/14/01  Verified for oracle9i<br>rem<br>COLUMN username        FORMAT a10  HEADING 'Holding|User'<br>COLUMN session_id                  HEADING 'SID'<br>COLUMN mode_held       FORMAT a10  HEADING 'Mode|Held'<br>COLUMN mode_requested  FORMAT a10  HEADING 'Mode|Requested'<br>COLUMN lock_id1        FORMAT a10  HEADING 'Lock|ID1'<br>COLUMN lock_id2        FORMAT a10  HEADING 'Lock|ID2'<br>COLUMN type                        HEADING 'Lock|Type'<br>SET LINES 132 PAGES 59 FEEDBACK OFF ECHO OFF<br>START title132 'Sessions Blocking Other Sessions Report'<br>SPOOL rep_out\&amp;db\blockers<br>SELECT<br>     a.session_id, username,type,mode_held,mode_requested,<br>     lock_id1,lock_id2<br> FROM<br>     sys.v_$session b,<br>     sys.dba_blockers c,<br>     sys.dba_lock a<br> WHERE<br>     c.holding_session=a.session_id AND<br>     c.holding_session=b.sid<br>/<br>SPOOL OFF<br>PAUSE press Enter to continue<br>CLEAR COLUMNS<br>SET LINES 80 PAGES 22 FEEDBACK ON<br>
<i>Quellcode 11.36: Berichtsskript für Sitzungen, die Blockaden verursachen</i><br>
<hr>
<A name=114></a>rem Name     : ddl_lock.sql<br>rem Function : Document DDL Locks currently in use<br>rem History  : MRA 1/15/97   Creation<br>rem            MRA 5/21/99   Reformat, verify for 8i<br>rem<br>COLUMN owner           FORMAT a7    HEADING 'User'<br>COLUMN session_id      FORMAT 9999  HEADING 'SID'<br>COLUMN mode_held       FORMAT a7    HEADING 'Lock|Mode|Held'<br>COLUMN mode_requested  FORMAT a7    HEADING 'Lock|Mode|Request'<br>COLUMN type            FORMAT a20   HEADING 'Type|Object'<br>COLUMN name            FORMAT a21   HEADING 'Object|Name'<br>SET FEEDBACK OFF ECHO OFF PAGES 48 LINES 79<br>START title80 'Report on All DDL Locks Held'<br>SPOOL rep_out\&amp;db\ddl_lock<br>SELECT<br>     NVL(owner,'SYS') owner, session_id,name,type,<br>     mode_held, mode_requested<br> FROM<br>     sys.dba_ddl_locks<br> ORDER BY 1,2,3<br>/<br>SPOOL OFF<br>PAUSE press Enter/return to continue<br>CLEAR COLUMNS<br>SET FEEDBACK ON PAGES 22 LINES 80<br>TTITLE OFF<br>
<i>Quellcode 11.37: Berichtsskript für DDL-Sperren</i><br>
<hr>
<A name=115></a>rem NAME     : int_lock.sql<br>rem FUNCTION : Document current internal locks<br>rem HISTORY  : MRA 1/15/96 Creation<br>rem<br>COLUMN username        FORMAT a10  HEADING 'Lock|Holder'<br>COLUMN session_id                  HEADING 'User|SID'<br>COLUMN lock_type       FORMAT a27  HEADING 'Lock Type'<br>COLUMN mode_held       FORMAT a10  HEADING 'Mode|Held'<br>COLUMN mode_requested  FORMAT a10  HEADING 'Mode|Requested'<br>COLUMN lock_id1        FORMAT a30  HEADING 'Lock/Cursor|ID1'<br>COLUMN lock_id2        FORMAT a10  HEADING 'Lock|ID2'<br>PROMPT 'ALL is all types or modes'<br>ACCEPT lock PROMPT 'Enter Desired Lock Type: '<br>ACCEPT mode PROMPT 'Enter Lock Mode: '<br>SET LINES 132 PAGES 59 FEEDBACK OFF ECHO OFF VERIFY OFF<br>BREAK ON username<br>START title132 'Report on Internal Locks Mode: &amp;mode Type: &amp;lock'<br>SPOOL rep_out\&amp;db\int_locks<br>SELECT<br>     NVL(b.username,'SYS') username,<br>     session_id,lock_type,mode_held,<br>     mode_requested,lock_id1,lock_id2<br> FROM<br>     sys.dba_lock_internal a, sys.v_$session b<br> WHERE<br>     UPPER(mode_held) like UPPER('%&amp;mode%') OR<br>     UPPER('&amp;mode')='ALL' AND<br>     UPPER(lock_type) like UPPER('%&amp;lock%') OR<br>     UPPER(mode_held) like UPPER('%&amp;mode%') OR<br>     UPPER('&amp;mode')='ALL' AND<br>     UPPER('&amp;lock')='ALL' AND<br>     a.session_id=b.sid<br> ORDER BY 1,2<br>/<br>SPOOL OFF<br>PAUSE press Enter to continue<br>SET LINES 80 PAGES 22 FEEDBACK ON VERIFY ON<br>CLEAR COLUMNS<br>CLEAR BREAKS<br>UNDEF LOCK<br>UNDEF MODE<br>
<i>Quellcode 11.38: Berichtsskript zur Dokumentation von aktuellen internen Sperren</i><br>
<hr>
<A name=116></a>rem<br>rem FUNCTION : Generate a report on session events by user<br>rem<br>rem NAME     : events.sql<br>rem HISTORY  : MRA 6/15/97   Created<br>rem            MRA 5/22/99   Verified on 8i<br>rem<br>COLUMN sid             HEADING Sid<br>COLUMN event           HEADING Event          FORMAT a40<br>COLUMN total_waits     HEADING Total|Waits<br>COLUMN total_timeouts  HEADING Total|Timeouts<br>COLUMN time_waited     HEADING Time|Waited<br>COLUMN average_wait    HEADING Average|Wait<br>COLUMN username        HEADING User<br>BREAK ON username<br>START title132 &quot;Session Events By User&quot;<br>SPOOL rep_out\&amp;db\events<br>SET LINES 132 PAGES 59 VERIFY OFF FEEDBACK OFF<br>SELECT<br>     username, event,total_waits,total_timeouts,<br>     time_waited,average_wait<br> FROM<br>     sys.v_$session_event a,<br>     sys.v_$session b<br> WHERE<br>     a.sid= b.sid<br> ORDER BY 1;<br>SPOOL OFF<br>PAUSE Press Enter to continue<br>CLEAR COLUMNS<br>CLEAR BREAKS<br>SET LINES 80 PAGES 22 VERIFY ON FEEDBACK ON<br>TTITLE OFF<br>
<i>Quellcode 11.39: Skript zur Erzeugung eines Ereignisberichts</i><br>
rem Name     : workspace_status.sql<br>rem Function : Show status of workspaces in database<br>rem<br>rem History  : MRA 10/14/2001  Initial Creation<br>rem<br>COLUMN WORKSPACE         FORMAT a10  HEADING 'Workspace'<br>COLUMN owner             FORMAT a10  HEADING 'Owner'<br>COLUMN freeze_status     FORMAT a8   HEADING 'Freeze|Status'<br>COLUMN resolve_status    FORMAT a8   HEADING 'Resolve|Status'<br>COLUMN parent_workspace  FORMAT a10  HEADING 'Parent|Workspace'<br>COLUMN freeze_mode       FORMAT a8   HEADING 'Freeze|Mode'<br>start title80 'Workspace Status'<br>spool rep_out\&amp;db\workspace_status<br>SELECT<br>     workspace,<br>     NVL(parent_workspace,'NONE') parent_workspace,<br>     owner,<br>     freeze_status,<br>     NVL(freeze_mode,'NONE') freeze_mode,<br>     resolve_status<br> FROM<br>     dba_workspaces<br>/<br>spool off<br>ttitle off<br>
<hr>
<A name=117></a><i>Quellcode 11.40: Berichtsskript für den Status eines Arbeitsbereichs</i><br>
<i>Abbildung 11.1: </i><br>
rem Name     : workspace_status.sql<br>rem Function : Show status of workspaces in database<br>rem<br>rem History  : MRA 10/14/2001  Initial Creation<br>rem<br>COLUMN WORKSPACE         FORMAT a10  HEADING 'Workspace'<br>COLUMN owner             FORMAT a10  HEADING 'Owner'<br>COLUMN freeze_status     FORMAT a8   HEADING 'Freeze|Status'<br>COLUMN resolve_status    FORMAT a8   HEADING 'Resolve|Status'<br>COLUMN parent_workspace  FORMAT a10  HEADING 'Parent|Workspace'<br>COLUMN freeze_mode       FORMAT a8   HEADING 'Freeze|Mode'<br>start title80 'Workspace Status'<br>spool rep_out\&amp;db\workspace_status<br>SELECT<br>     workspace,<br>     NVL(parent_workspace,'NONE') parent_workspace,<br>     owner,<br>     freeze_status,<br>     NVL(freeze_mode,'NONE') freeze_mode,<br>     resolve_status<br> FROM<br>     dba_workspaces<br>/<br>spool off<br>ttitle off<br>
<i>Quellcode 11.41: Berichtsskript für den Status eines Arbeitsbereichs</i><br>
<hr>
<A name=118></a>rem Name    : inv_obj.sql<br>rem Purpose : Show all invalid objects in database<br>rem Mike Ault 7/2/96<br>rem Mike Ault 10/14/01  verified for Oracle9i<br>rem<br>COLUMN object_name  FORMAT A20  HEADING 'Object|Name'<br>COLUMN owner        FORMAT a10  HEADING 'Object|Owner'<br>COLUMN last_time    FORMAT a18  HEADING 'Last Change|Date'<br>COLUMN object_type  FORMAT a15  Heading 'Object|Type'<br>SET LINES 80 FEEDBACK OFF PAGES 0 VERIFY OFF<br>START title80 'Invalid Database Objects'<br>SPOOL rep_out/&amp;db/inv_obj<br>SELECT<br>     owner,<br>     object_name,<br>     object_type,<br>     TO_CHAR(last_ddl_time,'DD-MON-YY hh:mi:ss') Last_time<br> FROM<br>     dba_objects<br> WHERE<br>     status='INVALID'<br>/<br>PAUSE Press Enter to continue<br>SET LINES 80 FEEDBACK ON PAGES 22 VERIFY ON<br>CLEAR COLUMNS<br>TTITLE OFF<br>
<i>Quellcode 11.42: Berichtsskript für den Objektstatus</i><br>
<hr>
<A name=119></a>rem Name     : com_proc.sql<br>rem Function : Create a compile list for invalid procedures<br>rem<br>rem MRA 5/1/96<br>rem<br>DEFINE cr='chr(10)'<br>SET HEADING OFF PAGES 0 ECHO OFF TERMOUT OFF FEEDBACK OFF VERIFY OFF<br>SPOOL recompile.sql<br>SELECT 'ALTER '||object_type||' '||object_name||' COMPILE;'||&amp;&amp;cr||<br>'SHOW ERROR'<br>FROM dba_objects WHERE status='INVALID'<br>/<br>SPOOL OFF<br>SET HEADING ON TERMOUT ON FEEDBACK ON VERIFY ON<br>UNDEF cr<br>
<i>Quellcode 11.43: Dynamisches SQL-Skript zur Neukompilierung ungültiger Objekte.</i><br>
<hr>
<A name=120></a>REM Name: sqldrd.sql<br>REM Function: return the sql statements from the shared area with<br>REM Function: highest disk reads<br>REM History: Presented in paper 35 at IOUG-A 1997, converted for<br>REM use 6/24/97 MRA<br>REM<br>DEFINE access_level = 10000 (NUMBER)<br>COLUMN parsing_user_id FORMAT 9999999     HEADING 'User Id'<br>COLUMN executions      FORMAT 9999        HEADING 'Exec'<br>COLUMN sorts           FORMAT 99999       HEADING 'Sorts'<br>COLUMN command_type    FORMAT 99999       HEADING 'CmdT'<br>COLUMN disk_reads      FORMAT 999,999,999 HEADING 'Block Reads'<br>COLUMN sql_text        FORMAT a40         HEADING 'Statement' WORD_WRAPPED<br>SET LINES 130 VERIFY OFF FEEDBACK OFF<br>START title132 'SQL Statements With High Reads'<br>SPOOL rep_out/&amp;db/sqldrd.lis<br>SELECT * FROM (SELECT<br>     parsing_user_id, executions,sorts,command_type,<br>     disk_reads,sql_text<br> FROM<br>     v$sqlarea<br> WHERE<br>     disk_reads &gt; &amp;&amp;access_level<br> ORDER BY<br>     disk_reads) WHERE rownum&lt;26;<br>SPOOL OFF<br>SET LINES 80 VERIFY ON FEEDBACK ON<br>
<i>Quellcode 12.1: SQL-Code zur Ausgabe der vorderen SQL-Anweisungen bei Sortierung nach Lesezugriffen</i><br>
<hr>
<A name=121></a>col sql_text format a40 word_wrapped<br>col username format a15<br>col sid format 999999<br>col system_date format a20 heading 'System|Date'<br>set lines 132 pages 50<br>@title132 'Sorters Report'<br>spool rep_out\&amp;db\sorters<br>select to_char(system_date,'dd-mon-yyyy hh24:mi') system_date,<br>sid,username,extents,blocks,sql_text from sorters<br>/<br>spool off<br>
The view used in the above script looks like:<br>
rem Code for view: SORTERS<br>CREATE OR REPLACE VIEW sorters as<br>select<br>SYSDATE system_date , s.sid, s.username<br>, b.extents, b.blocks, c.sql_text<br>from v$session s<br>, v$sort_usage b, v$sqlarea c<br>where s.saddr = b.session_addr<br>and s.sql_address = c.address;<br>
<i>Quellcode 12.2: Beispielskript zur Ermittlung von Angaben zu Sortiervorgängen</i><br>
<hr>
<A name=122></a>REM<br>REM NAME         : DD_CACHE.SQL<br>REM FUNCTION     : GENERATE REPORT ON DATA DICTIONARY CACHE <br>REM                CONDITION<br>REM USE          : FROM SQLPLUS<br>REM Limitations  : None<br>REM Revisions:<br>REM Date          Modified By     Reason For change<br>REM 21-AUG-1991     MIKE AULT     INITIAL CREATE<br>REM 27-NOV-1991     MIKE AULT     ADD % CALCULATION TO REPORT<br>REM 28-OCT-1992     MIKE AULT     ADD CALL TO TITLE PROCEDURE<br>REM 21-Jun-1997     MIKE AULT     Updated to ORACLE8<br>REM 07-nov-2001     MIKE AULT     Tested on 9i, reformatted<br>REM SET FLUSH OFF<br>REM SET TERM OFF<br>SET HEAD ON<br>SET PAGESIZE 59<br>SET LINESIZE 79<br>COLUMN parameter  FORMAT A20<br>COLUMN type       FORMAT a11<br>COLUMN percent    FORMAT 999.99   HEADING &quot;%&quot;;<br>COLUMN gets       FORMAT 999,999  HEADING 'Gets'<br>COLUMN getmisses  FORMAT 999,999  heading 'Get|Misses'<br>COLUMN count      FORMAT 999,999  heading 'Count'<br>COLUMN usage      FORMAT 999,999  HEADING 'Usage'<br>ttitle &quot;DATA DICTIONARY CACHE STATISTICS&quot;<br>SPOOL rep_out/ddcache.lis<br>SELECT <br>     parameter,<br>     type,<br>     gets,<br>     getmisses,<br>     ( getmisses / gets * 100) percent,<br>     count,<br>     usage<br> FROM <br>     v$rowcache     <br> WHERE <br>     gets &gt; 100 AND <br>     getmisses &gt; 0 <br> ORDER BY parameter;<br>SPOOL OFF<br>
<i>Quellcode 13.1: Bericht über den Cache des Data Dictionarys</i><br>
<hr>
<A name=123></a>REM Script to report on shared pool usage<br>REM<br>column shared_pool_used  format 9,999.99<br>column shared_pool_size  format 9,999.99<br>column shared_pool_avail format 9,999.99<br>column shared_pool_pct   format 999.99<br>@title80 'Shared Pool Summary'<br>spool rep_out\&amp;db\shared_pool<br>select  sum(a.bytes)/(1024*1024) shared_pool_used,<br>        max(b.value)/(1024*1024) shared_pool_size,<br>       (max(b.value)/(1024*1024))-(sum(a.bytes)/(1024*1024))<br>shared_pool_avail,<br>       (sum(a.bytes)/max(b.value))*100 shared_pool_pct<br> from v$sgastat a, v$parameter b<br> where a.pool = 'shared pool' and a.name != 'free memory'<br>       and b.name = 'shared_pool_size'<br>spool off<br>ttitle off<br>
<i>Quellcode 13.2: Berichtsskript zur Nutzung des gemeinsam nutzbaren Pools</i><br>
<hr>
<A name=124></a>rem FUNCTION: Creates summary of v_$sqlarea and dba_users for use<br>rem           in sqlmem.sql and sqlsummary.sql reports<br>rem<br>rem<br>create or replace view sql_summary as<br>select username, sharable_mem, persistent_mem, runtime_mem<br> from  sys.v_$sqlarea a, dba_users b<br> where a.parsing_user_id = b.user_id;<br>
<i>Quellcode 13.3: Skript zur Erstellung der Sicht für den SQL-Überblick</i><br>
<hr>
<A name=125></a>rem FUNCTION: Generate a summary of SQL Area Memory Usage<br>rem FUNCTION: uses the sqlsummary view.<br>rem           showing user SQL memory usage<br>rem sqlsum.sql<br>rem<br>column areas                           heading Used|Areas<br>column sharable    format 999,999,999  heading Shared|Bytes<br>column persistent  format 999,999,999  heading Persistent|Bytes<br>column runtime     format 999,999,999  heading Runtime|Bytes<br>column username    format a15          heading &quot;User&quot;<br>column mem_sum     format 999,999,999  heading Mem|Sum<br>start title80 &quot;Users SQL Area Memory Use&quot;<br>spool rep_out\&amp;db\sqlsum<br>set pages 59 lines 80<br>break on report<br>compute sum of sharable on report<br>compute sum of persistent on report<br>compute sum of runtime on report<br>compute sum of mem_sum on report<br>select username,<br>     sum(sharable_mem) Sharable,<br>     sum( persistent_mem) Persistent,<br>     sum( runtime_mem) Runtime ,<br>     count(*) Areas, sum(sharable_mem+persistent_mem+runtime_mem) Mem_sum<br> from sql_summary<br> group by username<br> order by 2;<br>spool off<br>pause Press enter to continue<br>clear columns<br>clear breaks<br>set pages 22 lines 80<br>ttitle off<br>
<i>Quellcode 13.4: Skript zur Erstellung des Berichts mit dem SQL-Überblick</i><br>
<hr>
<A name=126></a>rem FUNCTION: Generate a report of SQL Area Memory Usage<br>rem           showing SQL Text and memory catagories<br>rem sqlmem.sql<br>rem<br>column sql_text      format a60  heading Text word_wrapped<br>column sharable_mem              heading Shared|Bytes<br>column persistent_mem            heading Persistent|Bytes<br>column loads                     heading Loads<br>column users         format a15  heading &quot;User&quot;<br>column executions                heading &quot;Executions&quot;<br>column users_executing           heading &quot;Used By&quot;<br>start title132 &quot;Users SQL Area Memory Use&quot;<br>spool rep_out\&amp;db\sqlmem<br>set long 2000 pages 59 lines 132<br>break on users<br>compute sum of sharable_mem on users<br>compute sum of persistent_mem on users<br>compute sum of runtime_mem on users<br>select username users, sql_text, Executions, loads, users_executing,<br>     sharable_mem, persistent_mem<br>  from sys.v_$sqlarea a, dba_users b<br> where a.parsing_user_id = b.user_id<br>       and b.username like upper('%&amp;user_name%')<br> order by 3 desc,1;<br>spool off<br>pause Press enter to continue<br>clear columns<br>clear computes<br>clear breaks<br>set pages 22 lines 80<br>
<i>Quellcode 13.5: Beispielbericht über die SQL-Bereiche</i><br>
<hr>
<A name=127></a>REM View to sort SQL into GOOD and GARBAGE<br>REM<br>CREATE OR REPLACE VIEW sql_garbage AS<br>SELECT b.username users,<br>     SUM(a.sharable_mem+a.persistent_mem) Garbage,<br>     TO_NUMBER(null) good<br> FROM sys.v_$sqlarea a, dba_users b<br> WHERE (a.parsing_user_id = b.user_id and a.executions<b>&lt;=1</b>)<br> GROUP BY b.username<br>UNION<br>SELECT DISTINCT b.username users,<br>     TO_NUMBER(null) garbage,<br>     SUM(c.sharable_mem+c.persistent_mem) Good<br> FROM dba_users b, sys.v_$sqlarea c<br> WHERE (b.user_id = c.parsing_user_id and c.executions&gt;1)<br> GROUP BY b.username;<br>
<i>Quellcode 13.6: Sicht für die Nützlichkeit von SQL-Codes</i><br>
column garbage format a14 heading 'Non-Shared SQL'<br>column good format a14 heading 'Shared SQL'<br>column good_percent format a14 heading 'Percent Shared'<br>column users format a14 heading users<br>column nopr noprint<br>set feedback off<br>@title80 'Shared Pool Utilization'<br>spool rep_out\&amp;db\sql_garbage<br>select 1 nopr, a.users users,<br>     to_char(a.garbage,'9,999,999,999') garbage,<br>     to_char(b.good,'9,999,999,999') good,<br>     to_char((b.good/(b.good+a.garbage))*100,'9,999,999.999')<br>       good_percent<br> from sql_garbage a, sql_garbage b<br> where a.users=b.users<br>     and a.garbage is not null and b.good is not null<br>union<br>select 2 nopr, '-------------' users,<br>     '--------------' garbage,<br>     '--------------' good,<br>     '--------------' good_percent<br> from dual<br>union<br>select 3 nopr, to_char(count(a.users)) users,<br>     to_char(sum(a.garbage),'9,999,999,999') garbage,<br>     to_char(sum(b.good),'9,999,999,999') good,<br>     to_char(((sum(b.good)/(sum(b.good)+sum(a.garbage)))*100),<br>       '9,999,999.999') good_percent<br> from   sql_garbage a, sql_garbage b<br> where  a.users=b.users<br>     and a.garbage is not null and b.good is not null<br> order by 1,3 desc<br>/<br>spool off<br>
<i>Quellcode 13.7: Beispielskript für einen Bericht über die Nützlichkeit von SQL-Code</i><br>
<hr>
<A name=128></a>set lines 140 pages 55<br>col num_of_times heading 'Number|Of|Repeats'<br>col text heading 'SubString - &amp;&amp;chars Characters'<br>col username format a10 heading 'User'<br>@title132 'Similar SQL'<br>spool rep_out\&amp;db\similar_sql<br>select b.username,substr(a.sql_text,1,&amp;&amp;chars) text, count(a.sql_text) <br>num_of_times<br> from v$sqlarea a, dba_users b<br> where a.parsing_user_id=b.user_id<br> group by b.username,substr(a.sql_text,1,&amp;&amp;chars)<br> having count(a.sql_text)&gt;1<br> order by 3 desc<br>/<br>spool off<br>
<i>Quellcode 13.8: Bericht über ähnliche SQL-Anweisungen</i><br>
<hr>
<A name=129></a>rem FUNCTION: Report Stored Object Statistics<br>rem<br>column owner         format a11      heading Schema<br>column name          format a30      heading Object|Name<br>column namespace                     heading Name|Space<br>column type                          heading Object|Type<br>column kept          format a4       heading Kept<br>column sharable_mem  format 999,999  heading Shared|Memory<br>column executions    format 999,999  heading Executes<br>set lines 132 pages 47 feedback off<br>@title132 'Oracle Objects Report'<br>break on owner on namespace on type<br>spool rep_out/&amp;db/o_stat<br>select OWNER, NAMESPACE, TYPE, NAME, SHARABLE_MEM, LOADS,<br>     EXECUTIONS, LOCKS, KEPT<br> from   v$db_object_cache<br> where type not in (<br>     'NOT LOADED','NON-EXISTENT','VIEW','TABLE','SEQUENCE','PACKAGE BODY')<br>     and executions&gt;0 and loads&gt;1 and kept='NO'<br> order by owner,namespace,type,executions desc;<br>spool off<br>set lines 80 pages 22 feedback on<br>clear columns<br>clear breaks<br>ttitle off<br>
<i>Quellcode 13.9: Berichtsskript für die statistischen Werte von gespeicherten Objekten</i><br>
<hr>
<A name=130></a>REM Name: sqldrd.sql<br>REM Function: return the sql statements from the shared area with<br>REM Function: highest disk reads<br>REM History: Presented in paper 35 at IOUG-A 1997, converted for<br>REM use 6/24/97 MRA<br>REM<br>DEFINE access_level = 1000 (NUMBER)<br>COLUMN parsing_user_id FORMAT 9999999     HEADING 'User Id'<br>COLUMN executions      FORMAT 9999        HEADING 'Exec'<br>COLUMN sorts           FORMAT 99999       HEADING 'Sorts'<br>COLUMN command_type    FORMAT 99999       HEADING 'CmdT'<br>COLUMN disk_reads      FORMAT 999,999,999 HEADING 'Block Reads'<br>COLUMN sql_text        FORMAT a40    HEADING 'Statement' WORD_WRAPPED<br>SET LINES 130 VERIFY OFF FEEDBACK OFF<br>START title132 'SQL Statements With High Reads'<br>SPOOL rep_out/&amp;db/sqldrd.lis<br>SELECT<br>     parsing_user_id, executions,<br>     sorts, command_type,<br>     disk_reads, sql_text<br> FROM<br>     v$sqlarea<br> WHERE<br>     disk_reads &gt; &amp;&amp;access_level<br> ORDER BY<br>     disk_reads;<br>SPOOL OFF<br>SET LINES 80 VERIFY ON FEEDBACK ON<br>
<i>Quellcode 13.10: Bericht über Zusammenhänge zwischen SQL-Code und Festplattenlesezugriffen</i><br>
<hr>
<A name=131></a>rem Title: libcache.sql<br>rem FUNCTION: Generate a library cache report<br>column namespace                      heading &quot;Library Object&quot;<br>column gets          format 9,999,999 heading &quot;Gets&quot;<br>column gethitratio   format 999.99    heading &quot;Get Hit%&quot;<br>column pins          format 9,999,999 heading &quot;Pins&quot;<br>column pinhitratio   format 999.99    heading &quot;Pin Hit%&quot;<br>column reloads       format 99,999    heading &quot;Reloads&quot;<br>column invalidations format 99,999    heading  &quot;Invalid&quot;<br>column db            format a10<br>set pages 58 lines 80<br>start title80 &quot;Library Caches Report&quot;<br>define output = rep_out\&amp;db\lib_cache<br>spool &amp;output<br>select  namespace, gets, gethitratio*100 gethitratio,<br>     pins, pinhitratio*100 pinhitratio, RELOADS,<br>     INVALIDATIONS<br> from v$librarycache;<br>spool off<br>pause Press enter to continue<br>set pages 22 lines 80<br>ttitle off<br>undef output<br>
<i>Quellcode 13.11: Bericht über die Bibliothekscaches</i><br>
<hr>
<A name=132></a>rem<br>rem title:    ddcache.sql<br>rem FUNCTION: report on the v$rowcache table<br>rem HISTORY:  created sept 1995 MRA<br>rem<br>start title80 &quot;DD Cache Hit Ratio&quot;<br>spool rep_out\&amp;db\ddcache<br>SELECT (SUM(getmisses)/SUM(gets))*100 RATIO<br> FROM v$rowcache;<br>spool off<br>pause Press enter to continue<br>ttitle off<br>
<i>Quellcode 13.12: Überwachen des Trefferverhältnisses für das Data Dictionary</i><br>
<hr>
<A name=133></a>Rem db_cache_ad.sql<br>Rem from Oracle9<i>i  </i>tuning<br>Rem Mike Ault Initial creation<br>Rem<br>column size_est format 999,999,999,999 heading 'Cache Size (m)'<br>column buf_est  format 999,999,999     heading 'Buffers'<br>column estd_rf  format 999.90          heading 'Estd Phys|Read Factor'<br>column estd_pr  format 999,999,999     heading 'Estd Phys| Reads'<br>SET LINES 80 PAGES 55 <br>@title80 'DB Cache Advisor Report'<br>SPOOL rep_out/&amp;db/db_cache_ad<br>SELECT<br>     size_for_estimate size_est,<br>     buffers_for_estimate buf_est,<br>     estd_physical_read_factor est_rf,<br>     estd_physical_reads est_pr<br> FROM V$DB_CACHE_ADVICE<br> WHERE name = 'DEFAULT'<br>     AND block_size = (SELECT value FROM V$PARAMETER<br>                        WHERE name = 'db_block_size')<br>     AND advice_status = 'ON';<br>SPOOL OFF<br>SET PAGES 22<br>TTITLE OFF<br>
<i>Quellcode 13.13: Bericht über </i>DB_CACHE_ADVICE<br>
<hr>
<A name=134></a>rem block_usage.sql<br>rem<br>rem Mike AUlt - TUSC<br>rem<br>@title80 'Block Usage Inside SGA Block Buffers'<br>spool rep_out\&amp;db\block_usage<br>SELECT decode(c.name,null,'UNUSED',c.name) ts_name,<br>     a.file# file_number,<br>     COUNT(a.block#) Blocks,<br>     COUNT (DISTINCT a.file# || a.block#) Distinct_blocks<br> FROM V$BH a, file$ b, ts$ c<br> WHERE a.file#=b.file#(+)<br>     AND b.ts#=c.ts#(+)<br> GROUP BY a.file#,decode(c.name,null,'UNUSED',c.name)<br>/<br>spool off<br>
<i>Quellcode 13.14: Skript zur Blockbenutzung</i><br>
<hr>
<A name=135></a>rem vbh_status.sql<br>rem<br>rem Mike Ault -- Tusc<br>rem<br>@title80 'Status of DB Block Buffers'<br>spool rep_out\&amp;db\vbh_status<br>select status,count(*) number_buffers<br> from v$bh<br> group by status;<br>spool off<br>ttitle off<br>
<i>Quellcode 13.15: Skript für den </i>V$BH<i>-Status</i><br>
<hr>
<A name=136></a>rem dbwr_stat.sql<br>rem Mike Ault - TUSC 11/09/01 Created<br>rem<br>col name  format a46           heading 'DBWR Statistic'<br>col value format 9,999,999,999 heading 'Statistic Value'<br>set pages 40<br>@title80 'DBWR Statistic Report'<br>spool rep_out\&amp;db\dbwr_stat<br>select a.name,a.value<br> from (select name, value from v$sysstat<br>        where name not like '%redo%' and name not like '%remote%') a<br> where (a.name like 'DBWR%' or a.name like '%buffer%'<br>     or a.name like '%write%' or a.name like '%summed%)<br>union<br>select class name, count value<br> from v$waitstat<br> where class='data block''<br>union<br>select name||' '||to_char(block_size/1024)||'K hit ratio',<br>     round(((1 - (physical_reads / (db_block_gets + consistent_gets))) * 100),3) <br>value<br> from V$buffer_pool_statistics<br>union<br>select name||' '||to_char(block_size/1024)||'K free buffer wait',free_buffer_wait <br>value<br> from V$buffer_pool_statistics<br>union<br>select name||' '||to_char(block_size/1024)||'K buffer busy wait',buffer_busy_wait <br>value<br> from V$buffer_pool_statistics<br>union<br>select name||' '||to_char(block_size/1024)||'K write complete <br>wait',write_complete_wait value<br> from V$buffer_pool_statistics<br>/<br>spool off<br>set pages 22<br>ttitle off<br>
<i>Quellcode 13.16: Bericht zum Abrufen der statistischen Werte für den DBWR-Prozess</i><br>
<hr>
<A name=137></a>REM<br>REM NAME        :FILE_EFF.SQL<br>REM PURPOSE     :GENERATE FILE IO EFFICIENCIES REPORT<br>REM USE         :FROM STATUS_REPORTS.COM<br>REM Limitations :MUST BE RUN FROM ORACLE DBA ACCOUNT<br>REM Revisions:<br>REM Date          Modified By    Reason For change<br>REM 10-JUL-1992     M. AULT      INITIAL CREATE<br>REM 07-JUN-1993     M.AULT       Added reads to writes, reformatted<br>REM 23-Jun-1997     M.Ault       kcffio went away, rewrote to use<br>REM                              existing views/tables<br>SET PAGES 58 NEWPAGE 0<br>SET LINES 131<br>COLUMN eff   FORMAT A6         HEADING '% Eff'<br>COLUMN rw    FORMAT 9,999,999  HEADING 'Phys Block|read/writes'<br>COLUMN ts    FORMAT A22        HEADING 'Tablespace Name'<br>COLUMN name  FORMAT A40        HEADING 'File Name'<br>START title132 &quot;FILE IO EFFICIENCY&quot;<br>BREAK ON ts<br>DEFINE OUTPUT = 'rep_out/&amp;db/file_io.lis'<br>SPOOL &amp;OUTPUT<br>SELECT<br>     f.tablespace_name ts,<br>     f.file_name name,<br>     v.phyreads+v.phywrts rw,<br>     TO_CHAR(DECODE(v.phyblkrd,0,null,<br>     ROUND(100*(v.phyrds+v.phywrts)/(v.phyblkrd+v.phyblkwrt),2))) eff<br> FROM dba_data_files f, v$filestat v<br> WHERE f.file_id=v.file#<br> ORDER BY 1,file#;<br>SPOOL OFF<br>PAUSE Press return to continue<br>
<i>Quellcode 13.17: Bericht über die Dateieffizienz</i><br>
<hr>
<A name=138></a>REM<br>REM NAME     : DO_CALSTAT.SQL<br>REM FUNCTION :Generate calculated statisitics report using<br>REM FUNCTION :just_statistics procedure<br>REM USE     :FROM STATUS.SQL or SQLPLUS<br>REM Limitations      :<br>REM Revisions:<br>REM Date          Modified By     Reason For change<br>REM 05-MAY-1992     Mike Ault     Initial Creation<br>REM 23-JUN-1997     Mike Ault     Updated to V8<br>REM<br>SET PAGES 58  NEWPAGE 0<br>EXECUTE dba_utilities.running_stats(TRUE);<br>START title80 &quot;CALCULATED STATISTICS REPORT&quot;<br>DEFINE output = rep_out\&amp;db\cal_stat.lis<br>SPOOL &amp;output<br>SELECT * FROM dba_temp;<br>SPOOL OFF<br>
<i>Quellcode 13.18: Aufrufskript für </i>RUNNING_STATS<br>
<hr>
<A name=139></a>REM<br>REM FUNCTION: Generate a summary of Disk Sort Area Usage<br>REM<br>REM disksort.sql<br>REM<br>COLUMN value NEW_VALUE bs NOPRINT<br>SELECT value FROM v$parameter WHERE name='db block size';<br>START title80 &quot;Instance Disk Area Average Sizes&quot;<br>SPOOL rep_out\&amp;&amp;db\disk_sort<br>SELECT<br>     Tablespace_name,<br>     COUNT(*) areas,   (SUM(total_blocks)/COUNT(*))*&amp;&amp;bs avg_sort_bytes<br> FROM v$sort_segment<br> GROUP BY tablespace_name;<br>SPOOL OFF<br>
<i>Quellcode 13.19: Beispiel für Sortierungsbericht</i><br>
<hr>
<A name=140></a> <br>
rem<br>rem Name: mts_disp.sql<br>rem Funktion: Bericht für Prozentsatz beschäftigter Dispatcher erstellen<br>rem History: MRA 10/11/96 erstellt<br>rem          MRA 11/24/01 geprüft und formatiert für Oracle9i<br>rem<br>COL protocol FORMAT a60 HEADING 'Dispatcher|Protocol'<br>COL busy     FORMAT 999.99 HEADING 'Percent|Busy'<br>rem <br>SET FEEDBACK OFF VERIFY OFF LINES 78 PAGES 58<br>START title80 'Dispatcher-Status'<br>SPOOL rep_out\&amp;db\mts_disp <br>rem<br>SELECT network protocol,<br>      ((SUM(busy)/(SUM(busy)+SUM(idle)))*100) busy<br>FROM v$dispatcher<br>GROUP BY network;<br>rem<br>SPOOL OFF<br>SET FEEDBACK ON VERIFY ON LINES 22<br>TTITLE OFF<br>
<i>Quellcode 14.1: Beispielbericht für den Prozentsatz beschäftigter Dispatcher</i><br>
<hr>
<A name=141></a>rem<br>rem Name: mts_wait.sql<br>rem Funktion: Wartezeitbericht für die Dispatcher erstellen<br>rem History: MRA 10/11/96 erstellt<br>rem          MRA 11/25/01 geprüft in Oracle9i<br>rem <br>COLUMN network FORMAT a40 HEADING 'Dispatcher-|Protokoll' <br>COLUMN aw      FORMAT a32 HEADING 'Durchschnittl. Wartezeit %'<br>SET FEEDBACK OFF VERIFY OFF LINES 78 PAGES 55 <br>START title80 'Dispatcher-Wartezeiten'<br>SPOOL rep_out\&amp;db\mts_wait <br>SELECT<br>   NETWORK, <br>   DECODE (SUM(totalq),0,'no responses',<br>           SUM(wait)/SUM(totalq)*100||' sec wait/response') aw<br>FROM v$queue q, v$dispatcher d<br>WHERE q.type='DISPATCHER' AND<br>      q.paddr = d.paddr <br>GROUP BY network; <br>SPOOL OFF <br>SET FEEDBACK ON VERIFY ON PAGES 80 LINES 22<br>TTITLE OFF<br>
<i>Quellcode 14.2: Bericht über die durchschnittliche Wartezeit</i><br>
<hr>
<A name=142></a>rem <br>rem Name: mts_serv.sql <br>rem Funktion: Bericht über Prozentsatz beschäftigter gemeinsamer Server<br>rem History: MRA 11/24/01 geprüft und formatiert für Oracle9i<br>rem <br>COL name   FORMAT a4     HEADING 'Name'<br>COL busy   FORMAT 999.99 HEADING 'Prozentsatz' <br>COL status FORMAT a13    HEADING 'Serverstatus' <br>COL messages             HEADING 'Meldungen'   <br>COL bytes                HEADING 'Byte' <br>COL requests             HEADING 'Anforderungen'<br>rem <br>SET FEEDBACK OFF VERIFY OFF LINES 78 PAGES 58 <br>START title80 'Serverstatus' <br>SPOOL rep_out\&amp;db\mts_disp <br>rem <br>SELECT name,<br>      ((SUM(busy)/(SUM(busy)+SUM(idle)))*100) busy, <br>      MAX(status) status, MAX(messages) messages, <br>      MAX(bytes) bytes, MAX(requests) requests<br>FROM v$shared_server <br>GROUP BY name; <br>rem <br>SPOOL OFF <br>SET FEEDBACK ON VERIFY ON LINES 22 <br>TTITLE OFF<br>
<i>Quellcode 14.3: Skript zur Überwachung gemeinsam nutzbarer Serverprozesse</i><br>
<hr>
<A name=143></a> <br>
#**************************************************************<br># Name        : hot_backup<br># Purpose     : Perform a hot backup of an Oracle Database<br># Use         : sh hot_backup<br># Limitations : Creates a read-consistent image, but doesn't back<br>#               up in-process transactions<br>#<br># Revision History:<br># Date          Who              What<br># ---------     -----------      --------------------------------<br># June 1993     K. Loney         Featured in Oracle Mag. Article<br># 29-Jun-93     M. Ault          Modified, commented<br># 02-Aug-93     M. Ault          Converted to UNIX script<br># 03-Aug-93     M. Phillips      Added error detection<br>#****************************************************************<br>#<br>ERROR=&quot;FALSE&quot;<br>LOGFILE=&quot;$ORACLE_HOME/adhoc/scripts/hot_back_log&quot;<br>while [ &quot;$error&quot;=FALSE ]<br>do<br>svrmgrl &lt;&lt; ending1<br>     connect internal<br>     alter tablespace system begin backup;<br>     exit<br>ending1<br>     if ( tar cfv /oracle/backup /data/ORA_SYSTEM_1.DBF )<br>     then<br>          :<br>     else<br>          ERROR=&quot;TRUE&quot;;<br>          echo &quot;Tar backup failed for ora_system1.dbf&quot; &gt;$LOGFILE<br>     fi<br>svrmgrl &lt;&lt; ending2<br>connect internal<br>     alter tablespace system end backup;<br>     exit<br>ending2<br>
dup_it=&quot;tar rv /oracle/backup&quot;<br>svrmgrl &lt;&lt; ending3<br>connect internal<br>     alter tablespace user_tables begin backup;<br>     exit<br>ending3<br>if ( $dup_it /data/ora_user_tables_1.dbf )<br>then<br>     :<br>else<br>     ERROR=&quot;TRUE&quot;;echo &quot;Tar backup failed for ora_user_tables_1.dbf&quot;&gt;&gt;$LOGFILE<br>fi #we must still end backup for tablespaces<br>svrmgrl &lt;&lt; ending4<br>     connect internal<br>     alter tablespace user_tables end backup;<br>     exit<br>ending4<br># force write of all archive logs<br>svrmgrl &lt;&lt; ending5<br>     connect internal<br>     alter system switch logfile;<br>     archive log all;<br>     exit<br>ending5<br>if ( cp /usr/oracle/oracle7/db_example.archives/*.arc *.oldarc )<br>then<br>     :<br>
<hr>
<A name=144></a>else<br>     ERROR=&quot;TRUE&quot;;echo &quot;Copy of archive logs failed&quot;&gt;&gt;$LOGFILE<br>fi<br># Now backup a control file<br>svrmgrl &lt;&lt; ending6<br>     connect internal<br>     alter database example<br>     backup controlfile to<br>     '/usr/oracle/oracle7/db_example/ora_control.bac<br>     reuse;<br>     exit<br>ending6<br>if ( $dup_it /usr/oracle/oracle7/db_example/ora_control.bac )<br>then<br>     :<br>else<br>     ERROR=&quot;TRUE&quot;;echo "Tar backup failed for control file"&gt;&gt;$LOGFILE<br>fi<br># now backup all archive logs<br>if ( $dup_it /usr/oracle/oracle7/db_example.archives/*.oldarc )<br>then<br>     :<br>else<br>     ERROR=&quot;TRUE&quot;;echo "Tar backup failed for archive files&quot;&gt;&gt;$LOGFILE<br>fi<br># Now delete logs<br>if ( rm /usr/m_oracle/oracle7/db_examples.archives/*.oldarc;* )<br>then<br>     ERROR=&quot;TRUE&quot;<br>else<br>     ERROR=&quot;TRUE&quot;;echo "Delete of archive files failed"&gt;&gt;$LOGFILE<br>fi<br>done<br>exit<br>done<br>
<i>Quellcode 15.1: Beispielskript für ein Online-Backup unter Unix mit der Korne-Shell</i><br>
<hr>
<A name=145></a>REM Script to create a hot backup script on UNIX<br>REM Created 6/23/98 MRA<br>REM<br>create table bu_temp (line_no number,line_txt varchar2(2000))<br>storage (initial 1m next 1m pctincrease 0);<br>truncate table bu_temp;<br>set verify off embedded off lines 1000 termout off long 1000<br>define dest_dir=&amp;1;<br>declare<br>--<br>-- Declare cursors<br>--<br>-- Cursor to get all tablespace names<br>--<br>cursor get_tbsp is<br>select tablespace_name from dba_tablespaces;<br>--<br>-- cursor to create BEGIN BACKUP command<br>--<br>cursor bbu_com (tbsp varchar2) is<br>select<br>'alter tablespace '||tablespace_name||' begin backup;'<br>from dba_tablespaces where tablespace_name=tbsp;<br>--<br>-- Cursor to create HOST backup commands<br>--<br>cursor tar1_com (tbsp varchar2) is<br>select '! /bin/tar cvf - '||file_name<br>from dba_data_files where tablespace_name=tbsp<br>and file_id=(select min(file_id)from dba_data_files<br>where tablespace_name=tbsp);<br>--<br>cursor tar2_com (tbsp varchar2) is<br>select<br>file_name<br>from dba_data_files where tablespace_name=tbsp<br>and file_id&gt;(select min(file_id) from dba_data_files<br>where tablespace_name=tbsp);<br>--<br>cursor tar3_com (tbsp varchar2) is<br>select '! /bin/tar cvf - '||file_name<br>from dba_data_files where tablespace_name=tbsp<br>and file_id=(select min(file_id)from dba_data_files<br>where tablespace_name=tbsp);<br>--<br>cursor comp_com (tbsp varchar2) is<br>select<br>'|compress -c<br>&gt;&amp;&amp;dest_dir/'||tablespace_name||'_'||to_char(sysdate,'dd_mon_yy')||'.Z'||chr(<br>10)<br>from dba_tablespaces where tablespace_name=tbsp;<br>--<br>-- Cursor to create END BACKUP command<br>--<br>cursor ebu_com (tbsp varchar2) is<br>select<br>'alter tablespace '||tablespace_name||' end backup;' from<br>dba_tablespaces<br>where tablespace_name=tbsp;<br>--<br>-- Cursor to create redo log HOST backup commands<br>--<br>cursor tar1_rdo is<br>select '! /bin/tar cvf - '<br>from dual;<br>
<hr>
<A name=146></a>--<br>cursor tar2_rdo is<br>select<br>member||' '<br>from v$logfile;<br>--<br>cursor comp_rdo is<br>select<br>'|compress -c<br>&gt;&amp;&amp;dest_dir/redo_logs_'||to_char(sysdate,'dd_mon_yy')||'.Z'||chr(10)<br>from dual;<br>--<br>-- Temporary variable declarations<br>--<br>tbsp_name varchar2(64);<br>line_num number:=0;<br>line_text varchar2(2000);<br>fetch_text varchar2(2000);<br>min_value number;<br>first_tbsp boolean;<br>temp_var varchar2(128);<br>--<br>-- Begin build of commands into temporary table<br>--<br>begin<br>--<br>-- first, create script header<br>--<br>line_num := line_num+1;<br>select 'REM Online Backup Script for '||name||' instance'<br>into line_text from v$database;<br>insert into bu_temp values (line_num,line_text);<br>line_num := line_num+1;<br>select 'REM Script uses UNIX tar format backup commands'<br>into line_text from dual;<br>insert into bu_temp values (line_num,line_text);<br>line_num := line_num+1;<br>select 'REM created on '||to_char(sysdate, 'dd-mon-yyyy hh24:mi')||' by user<br>'||user<br>into line_text from dual;<br>insert into bu_temp values (line_num,line_text);<br>line_num := line_num+1;<br>select 'REM developed by Mike Ault - TUSC 2-May-2001'<br>into line_text from dual;<br>insert into bu_temp values (line_num,line_text);<br>line_num := line_num+1;<br>select 'REM Script expects to be fed backup directory location on execution.'<br>into line_text from dual;<br>insert into bu_temp values (line_num,line_text);<br>line_num := line_num+1;<br>select 'REM Script should be re-run anytime physical structure of database<br>altered.'<br>into line_text from dual;<br>insert into bu_temp values (line_num,line_text);<br>line_num := line_num+1;<br>select 'REM '<br>into line_text from dual;<br>insert into bu_temp values (line_num,line_text);<br>line_num := line_num+1;<br>select 'spool &amp;&amp;dest_dir/log/hot_bu'||to_char(sysdate,'dd_mon_yy')||'.log'<br>into line_text from dual;<br>insert into bu_temp values (line_num,line_text);<br>line_num := line_num+1;<br>--<br>-- Now get tablespace names and loop through until all are handled<br>--<br>commit;<br>
<hr>
<A name=147></a>open get_tbsp;<br>first_tbsp:=TRUE;<br>loop<br>--<br>-- Get name<br>--<br>     fetch get_tbsp into tbsp_name;<br>     exit when get_tbsp%NOTFOUND;<br>--<br>-- Add comments to script showing which tablespace<br>--<br>     select 'REM' into line_text from dual;<br>     insert into bu_temp values (line_num,line_text);<br>     line_num:=line_num+1;<br>     select 'REM Backup for tablespace '||tbsp_name into line_text from dual;<br>     insert into bu_temp values (line_num,line_text);<br>     line_num:=line_num+1;<br>     select 'REM' into line_text from dual;<br>     insert into bu_temp values (line_num,line_text);<br>     line_num:=line_num+1;<br>--<br>-- Get begin backup command built for this tablespace<br>--<br>     open bbu_com (tbsp_name);<br>     fetch bbu_com into line_text;<br>     insert into bu_temp values (line_num,line_text);<br>     line_num:=line_num+1;<br>     close bbu_com;<br>--<br>-- The actual backup commands are per datafile, open cursor and loop<br>--<br>     open tar1_com (tbsp_name);<br>     open tar2_com (tbsp_name);<br>     open tar3_com (tbsp_name);<br>     open comp_com (tbsp_name);<br>     min_value:=1;<br>     line_text:=NULL;<br>     loop<br>          if min_value=1<br>          then<br>            if first_tbsp THEN<br>              fetch tar1_com into fetch_text;<br>              select trim(fetch_text) into line_text from dual;<br>            else<br>              fetch tar3_com into fetch_text;<br>              select trim(fetch_text) into line_text from dual;<br>          end if;<br>          else<br>            fetch tar2_com into fetch_text;<br>            exit when tar2_com%NOTFOUND;<br>            select trim(line_text)||' '||trim(fetch_text) into line_text from <br>dual;<br>          end if;<br>          first_tbsp:=FALSE;<br>          min_value:=min_value+1;<br>     end loop;<br>     fetch comp_com into fetch_text;<br>     select trim(line_text)||' '||trim(fetch_text) into line_text from dual;<br>     insert into bu_temp values (line_num,line_text);<br>     line_num:=line_num+1;<br>     close tar1_com;<br>     close tar2_com;<br>     close tar3_com;<br>     close comp_com;<br>--<br>-- Build end backup command for this tablespace<br>--<br>
<hr>
<A name=148></a>  open ebu_com(tbsp_name);<br>  fetch ebu_com into line_text;<br>  insert into bu_temp values (line_num,line_text);<br>  line_num:=line_num+1;<br>  close ebu_com;<br>end loop;<br>  close get_tbsp;<br>--<br>-- Backup redo logs, normally you won't recover redo logs you<br>-- will use your current redo logs so current SCN information not lost<br>-- commands just here for completeness<br>--<br>  select 'REM' into line_text from dual;<br>  insert into bu_temp values (line_num,line_text);<br>  line_num:=line_num+1;<br>  select 'REM Backup for redo logs' into line_text from dual;<br>  insert into bu_temp values (line_num,line_text);<br>  line_num:=line_num+1;<br>  select 'REM Normally you will not recover redo logs' into line_text from dual;<br>  insert into bu_temp values (line_num,line_text);<br>  line_num:=line_num+1;<br>  select 'REM' into line_text from dual;<br>  insert into bu_temp values (line_num,line_text);<br>  line_num:=line_num+1;<br>--<br>-- Create host backup commands for all redo logs<br>--<br>  open tar1_rdo;<br>  open tar2_rdo;<br>  open comp_rdo;<br>  min_value:=1;<br>  loop<br>    if min_value=1<br>    then<br>      fetch tar1_rdo into fetch_text;<br>      select trim(fetch_text) into line_text from dual;<br>    else<br>      fetch tar2_rdo into fetch_text;<br>      select trim(line_text)||' '||trim(fetch_text) into line_text from dual;<br>      exit when tar2_rdo%NOTFOUND;<br>    end if;<br>    min_value:=min_value+1;<br>  end loop;<br>  fetch comp_rdo into fetch_text;<br>  select trim(line_text)||' '||trim(fetch_text) into line_text from dual;<br>  insert into bu_temp values (line_num,line_text);<br>  line_num:=line_num+1;<br>  close tar1_rdo;<br>  close tar2_rdo;<br>  close comp_rdo;<br>--<br>-- Now get all archive logs, performing a switch to be sure all<br>-- required archives are written out<br>--<br>  select 'REM' into line_text from dual;<br>  insert into bu_temp values (line_num,line_text);<br>  line_num:=line_num+1;<br>  select 'REM Backup for archive logs' into line_text from dual;<br>  insert into bu_temp values (line_num,line_text);<br>  line_num:=line_num+1;<br>  select 'REM' into line_text from dual;<br>  insert into bu_temp values (line_num,line_text);<br>  line_num:=line_num+1;<br>  select 'alter system switch logfile;' into line_text from dual;<br>  insert into bu_temp values (line_num,line_text);<br>  line_num:=line_num+1;<br>  select 'alter system archive log all;' into line_text from dual;<br>
<hr>
<A name=149></a>  insert into bu_temp values (line_num,line_text);<br>  line_num:=line_num+1;<br>--<br>-- The next command builds the actual backup command based on the<br>-- value of the log_archive_dest initialization parameter, it looks for the<br>-- last right square bracket in the name and just uses that section with<br>-- a wildcard<br>--<br>  temp_var:=null;<br>  select substr (value,1,instr(value,'/',-1,1)) into temp_var<br>  from v$parameter where name='log_archive_dest';<br>  if temp_var is not null<br>  then<br>    select '! compress '||substr (value,1,instr(value,'/',-1,1))||'/*'<br>    into line_text from v$parameter where name='log_archive_dest';<br>    insert into bu_temp values (line_num,line_text);<br>    line_num:=line_num+1;<br>    select '! tar cvf - '||substr (value,1,instr(value,'/',-1,1))||'/*.Z'||<br>    '|compress -c &gt;&amp;&amp;dest_dir/'||<br>    substr (value,instr(value,'/',-<br>1,1)+1,length(value))||'_'||to_char(sysdate,'dd_mon_yy')||'.Z'<br>    into line_text from v$parameter where name='log_archive_dest';<br>    insert into bu_temp values (line_num,line_text);<br>    line_num:=line_num+1;<br>  else<br>    select 'REM no log_archive_dest specified' into line_text from dual;<br>    insert into bu_temp values (line_num,line_text);<br>    line_num:=line_num+1;<br>  end if;<br>  temp_var:=null;<br>  select substr (value,10,instr(value,'/',-1,1)) into temp_var<br>  from v$parameter where name='log_archive_dest_1';<br>  if temp_var is not null<br>  then<br>    select '! compress '||substr (value,10,instr(value,'/',-1,1))||'/*'<br>    into line_text from v$parameter where name='log_archive_dest_1';<br>    insert into bu_temp values (line_num,line_text);<br>    line_num:=line_num+1;<br>    select '! tar cvf - '||substr (value,10,instr(value,'/',-1,1))||'/*.Z'||<br>    '|compress -c &gt;&amp;&amp;dest_dir/'||<br>    substr (value,instr(value,'/',-<br>1,1)+1,length(value))||'_'||to_char(sysdate,'dd_mon_yy')||'.Z'<br>    into line_text from v$parameter where name='log_archive_dest_1';<br>    insert into bu_temp values (line_num,line_text);<br>    line_num:=line_num+1;<br>  else<br>    select 'REM no log_archive_dest_1 specified' into line_text from dual;<br>    insert into bu_temp values (line_num,line_text);<br>    line_num:=line_num+1;<br>  end if;<br>--<br>-- Next, backup a control file just to be sure<br>-- we have a good one available that is current with this backup<br>--<br>  select 'alter database backup controlfile to<br>'||chr(39)||'&amp;&amp;dest_dir'||'/ora_cnbkp_'||to_char(sysdate,'dd_mon_yy')||'.bac'<br>||chr(39)||';'<br>  into line_text from dual;<br>  insert into bu_temp values (line_num,line_text);<br>  line_num:=line_num+1;<br>  select 'spool off'||chr(10) into line_text from dual;<br>  insert into bu_temp values (line_num,line_text);<br>  line_num:=line_num+1;<br>  commit;<br>end;<br>/<br>rem<br>
<hr>
<A name=150></a>rem Now generate output based on bu_temp table contents<br>rem<br>set verify off feedback off heading off termout off pages 0<br>set embedded on lines 1000<br>column line_no noprint<br>column dbname new_value db noprint<br>select value dbname from v$parameter where name='db_name';<br>spool rep_out/&amp;db/thot_bu.sql<br>select * from bu_temp order by line_no;<br>spool off<br>rem directory syntax for UNIX<br>rem<br>! sed '1,$ s/ *$//g' rep_out/&amp;db/thot_bu.sql&gt;rep_out/&amp;db/hot_bu.sql<br>rem<br>drop table bu_temp;<br>set verify on feedback on heading on termout on pages 22<br>set embedded off lines 80<br>clear columns<br>undef dest_dir<br>
<i>Quellcode 15.2: Beispielskript zur Erzeugung eines Skripts für Online-Backups unter Unix</i><br>
<hr>
<A name=151></a>REM Online Backup Script for AULTDB1 instance<br>REM Script uses UNIX tar format backup commands<br>REM created on 27-nov-2001 11:21 by user SYSTEM<br>REM developed by Mike Ault - TUSC 2-May-2001<br>REM Script expects to be fed backup directory location on execution.<br>REM Script should be re-run anytime physical structure of database altered.<br>REM<br>spool /opt/backup/aultdb1/log/hot_bu27_nov_01.log<br>REM<br>REM Backup for tablespace SYSTEM<br>REM<br>alter tablespace SYSTEM begin backup;<br>! /bin/tar cvf - /ora1/ORACLE/ORADATA/AULTDB1/SYSTEM01.DBF |compress -c<br>&gt;/opt/backup/aultdb1/SYSTEM_27_nov_01.Z<br>alter tablespace SYSTEM end backup;<br>REM<br>REM Backup for tablespace RBS<br>REM<br>alter tablespace RBS begin backup;<br>! /bin/tar cvf - /ora2/ORACLE/ORADATA/AULTDB1/RBS01.DBF |compress -c<br>&gt;/opt/backup/aultdb1/RBS_27_nov_01.Z<br>alter tablespace RBS end backup;<br>REM<br>REM Backup for tablespace USERS<br>REM<br>alter tablespace USERS begin backup;<br>! /bin/tar cvf - /ora3/ORACLE/ORADATA/AULTDB1/USERS01.DBF |compress -c<br>&gt;/opt/backup/aultdb1/USERS_27_nov_01.Z<br>alter tablespace USERS end backup;<br>REM<br>REM Backup for tablespace TEMP<br>REM<br>alter tablespace TEMP begin backup;<br>! /bin/tar cvf - /ora4/ORACLE/ORADATA/AULTDB1/TEMP01.DBF |compress -c<br>&gt;/opt/backup/aultdb1/TEMP_27_nov_01.Z<br>alter tablespace TEMP end backup;<br>REM<br>REM Backup for tablespace TOOLS<br>REM<br>alter tablespace TOOLS begin backup;<br>! /bin/tar cvf - /ora5/ORACLE/ORADATA/AULTDB1/TOOLS01.DBF |compress -c<br>&gt;/opt/backup/aultdb1/TOOLS_27_nov_01.Z<br>alter tablespace TOOLS end backup;<br>REM<br>REM Backup for tablespace INDX<br>REM<br>alter tablespace INDX begin backup;<br>! /bin/tar cvf - /ora5/ORACLE/ORADATA/AULTDB1/INDX01.DBF |compress -c<br>&gt;/opt/backup/aultdb1/INDX_27_nov_01.Z<br>alter tablespace INDX end backup;<br>REM<br>REM Backup for tablespace DRSYS<br>REM<br>alter tablespace DRSYS begin backup;<br>! /bin/tar cvf - /ora1/ORACLE/ORADATA/AULTDB1/DR01.DBF |compress -c<br>&gt;/opt/backup/aultdb1/DRSYS_27_nov_01.Z<br>alter tablespace DRSYS end backup;<br>REM<br>REM Backup for tablespace PERFSTAT<br>REM<br>alter tablespace PERFSTAT begin backup;<br>! /bin/tar cvf - /ora1/ORACLE/ORADATA/AULTDB1/PERFSTAT.DBF |compress -c<br>&gt;/opt/backup/aultdb1/PERFSTAT_27_nov_01.Z<br>alter tablespace PERFSTAT end backup;<br>REM<br>
<hr>
<A name=152></a>REM Backup for tablespace TEST_2K<br>REM<br>alter tablespace TEST_2K begin backup;<br>! /bin/tar cvf - /ora2/ORACLE/ORADATA/AULTDB1/TEST_2K.DBF |compress -c<br>&gt;/opt/backup/aultdb1/TEST_2K_27_nov_01.Z<br>alter tablespace TEST_2K end backup;<br>REM<br>REM Backup for redo logs<br>REM Normally you will not recover redo logs<br>REM<br>! /bin/tar cvf - /ora6/ORACLE/ORADATA/AULTDB1/REDO011.LOG<br>/ora6/ORACLE/ORADATA/AULTDB1/REDO032.LOG<br>/ora7/ORACLE/ORADATA/AULTDB1/REDO021.LOG<br>/ora7/ORACLE/ORADATA/AULTDB1/REDO012.LOG<br>/ora8/ORACLE/ORADATA/AULTDB1/REDO031.LOG<br>/ora8/ORACLE/ORADATA/AULTDB1/REDO022.LOG |compress -c<br>&gt;/opt/backup/aultdb1/redo_logs_27_nov_01.Z<br>REM<br>REM Backup for archive logs<br>REM<br>alter system switch logfile;<br>alter system archive log all;<br>host compress /ora9/ORACLE/ORADATA/AULTDB1/ARCHIVE/*<br>host tar cvrf - *.Z|compress&gt;/tape1/_25_may_99.Z<br>alter database backup controlfile to<br>'/opt/backup/aultdb1/ora_cnbkp_27_nov_01.bac';<br>spool off<br>
<i>Quellcode 15.3: Beispielausgabe des generierten Skripts für Online-Backups</i><br>
<hr>
<A name=153></a>REM Script to create a hot backup recovery script on NT using ocopy<br>REM Created 6/23/98 MRA<br>REM<br>create table bu_temp (line_no number,line_txt varchar2(2000));<br>truncate table bu_temp;<br>set verify off embedded off esc ^<br>REM &amp;&amp;ora_home &amp;&amp;dest_dir<br>column dup new_value dup_it noprint<br>select ''||chr(39)||'&amp;&amp;ora_home'||'\ocopy '||chr(39)||'' dup<br>from dual;<br>
declare<br>--<br>-- Declare cursors<br>--<br>-- Cursor to get all tablespace names<br>--<br>cursor get_tbsp is<br>select tablespace_name from dba_tablespaces;<br>--<br>-- Cursor to create recovery commands<br>--<br>cursor rec_com (tbsp varchar2) is<br>select<br>&amp;&amp;dup_it||' '||'&amp;&amp;dest_dir'||'\datafiles\'||tbsp||file_id||'.bck '||file_name<br>from dba_data_files where tablespace_name=tbsp;<br>--<br>-- Cursor to create redo log recovery commands<br>--<br>cursor rec_rdo (num number) is<br>select<br>&amp;&amp;dup_it||<br>'<br>'||'&amp;&amp;dest_dir'||'\logs'||substr(member,instr(member,'\LOG',2,1),instr(member<br>,'.',1,1))||' '||<br>member<br>from v$logfile order by group#;<br>--<br>-- Temporary variable declarations<br>--<br>tbsp_name varchar2(64);<br>line_num number:=0;<br>line_text varchar2(2000);<br>num number:=0;<br>--<br>-- Begin build of commands into temporary table<br>--<br>begin<br>--<br>-- first, create script header<br>--<br>line_num := line_num+1;<br>select 'REM Recovery Script for '||name||' instance'<br>into line_text from v$database;<br>insert into bu_temp values (line_num,line_text);<br>line_num := line_num+1;<br>select 'REM Script uses ocopy - NT format backup commands'<br>into line_text from dual;<br>insert into bu_temp values (line_num,line_text);<br>line_num := line_num+1;<br>select 'REM created on '||to_char(sysdate, 'dd-mon-yyyy hh24:mi')||' by user<br>'||user<br>into line_text from dual;<br>insert into bu_temp values (line_num,line_text);<br>line_num := line_num+1;<br>
<hr>
<A name=154></a>select 'REM developed for RevealNet by Mike Ault - DMR Consulting 15-Dec-<br>1998'<br>into line_text from dual;<br>insert into bu_temp values (line_num,line_text);<br>line_num := line_num+1;<br>select 'REM '<br>into line_text from dual;<br>insert into bu_temp values (line_num,line_text);<br>line_num := line_num+1;<br>select 'REM Script should be re-run anytime physical structure of database<br>altered.'<br>into line_text from dual;<br>insert into bu_temp values (line_num,line_text);<br>line_num := line_num+1;<br>select 'REM '<br>into line_text from dual;<br>insert into bu_temp values (line_num,line_text);<br>line_num := line_num+1;<br>--<br>-- Now get tablespace names and loop through until all are handled<br>--<br>open get_tbsp;<br>loop<br>--<br>-- Get name<br>--<br>     fetch get_tbsp into tbsp_name;<br>     exit when get_tbsp%NOTFOUND;<br>--<br>-- Add comments to script showing which tablespace<br>--<br>     select 'REM' into line_text from dual;<br>     insert into bu_temp values (line_num,line_text);<br>     line_num:=line_num+1;<br>     select 'REM Recovery for tablespace '||tbsp_name into line_text from dual;<br>     insert into bu_temp values (line_num,line_text);<br>     line_num:=line_num+1;<br>     select 'REM' into line_text from dual;<br>     insert into bu_temp values (line_num,line_text);<br>     line_num:=line_num+1;<br>--<br>-- The actual recovery commands are per datafile, open cursor and loop<br>--<br>     open rec_com (tbsp_name);<br>     loop<br>          fetch rec_com into line_text;<br>          exit when rec_com%NOTFOUND;<br>          line_num:=line_num+1;<br>          insert into bu_temp values (line_num,line_text);<br>     end loop;<br>     close rec_com;<br>end loop;<br>close get_tbsp;<br>--<br>-- Recover redo logs, normally you won't recover redo logs you<br>-- will use your current redo logs so current SCN information not lost<br>-- commands just here for completeness uncomment commands below to<br>-- enable redo log recovery (not advised)<br>--<br>  select 'REM' into line_text from dual;<br>  insert into bu_temp values (line_num,line_text);<br>  line_num:=line_num+1;<br>  select 'REM Recovery for redo logs' into line_text from dual;<br>  insert into bu_temp values (line_num,line_text);<br>  line_num:=line_num+1;<br>  select 'REM Normally you will not recover redo logs' into line_text from dual;<br>  insert into bu_temp values (line_num,line_text);<br>
<hr>
<A name=155></a>  line_num:=line_num+1;<br>  select 'REM' into line_text from dual;<br>  insert into bu_temp values (line_num,line_text);<br>  line_num:=line_num+1;<br>--<br>-- Create host backup commands for all redo logs<br>--<br>  /*open rec_rdo(num);<br>  loop<br>      fetch rec_rdo into line_text;<br>      exit when rec_rdo%NOTFOUND;<br>      num:=num+1;<br>      line_num:=line_num+1;<br>      insert into bu_temp values (line_num,line_text);<br>  end loop;<br>  close rec_rdo;*/<br>--<br>-- Now recover all archive logs<br>--<br>  line_num:=line_num+1;<br>  select 'REM' into line_text from dual;<br>  insert into bu_temp values (line_num,line_text);<br>  line_num:=line_num+1;<br>  select 'REM Recovery for archive logs' into line_text from dual;<br>  insert into bu_temp values (line_num,line_text);<br>  line_num:=line_num+1;<br>  select 'REM' into line_text from dual;<br>  insert into bu_temp values (line_num,line_text);<br>  line_num:=line_num+1;<br>--<br>-- The next command builds the actual recovery command based on the<br>-- value of the log_archive_dest initialization parameter, it looks for the<br>-- last right square bracket in the name and just uses that section with<br>-- a wildcard<br>--<br>  select &amp;&amp;dup_it||' '||'&amp;&amp;dest_dir'||'\archives\*.* '||value||'\*.*'<br>  into line_text from v$parameter where name='log_archive_dest';<br>  line_num:=line_num+1;<br>  insert into bu_temp values (line_num,line_text);<br>end;<br>/<br>rem<br>rem Now generate output based on bu_temp table contents<br>rem<br>set verify off feedback off heading off termout off pages 0<br>set embedded on lines 132<br>column db_name new_value db noprint<br>column line_no noprint<br>select name db_name from v$database;<br>spool rep_out\&amp;&amp;db\rec_db.bat<br>select * from bu_temp order by line_no;<br>spool off<br>rem<br>rem get rid of bu_temp table<br>rem<br>drop table bu_temp;<br>set verify on feedback on heading on termout on pages 22<br>set embedded off lines 80 esc \<br>clear columns<br>undef ora_home<br>undef dest_dir<br>exit<br>
<i>Quellcode 15.4: Beispielskript zur Erzeugung eines Recovery-Skripts unter NT</i><br>
<hr>
</BODY>
</HTML>
